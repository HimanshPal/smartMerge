// Code generated by protoc-gen-gogo.
// source: dc-smartMerge.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		dc-smartMerge.proto

	It has these top-level messages:
		State
		Conf
		ConfReply
		Node
		Blueprint
		NewCur
		NewCurReply
		Read
		ReadReply
		WriteS
		AdvRead
		AdvReadReply
		AdvWriteS
		AdvWriteSReply
		WriteN
		WriteNReply
		LAProposal
		LAReply
		NewState
		NewStateReply
		DRead
		DWriteN
		DWriteNReply
		GetOne
		GetOneReply
		CV
		Prepare
		Promise
		Propose
		Learn
*/
package proto

import proto1 "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	"encoding/binary"
	"errors"
	"hash/fnv"
	"log"
	"sort"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type State struct {
	Value     []byte `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Timestamp int32  `protobuf:"varint,2,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Writer    uint32 `protobuf:"varint,3,opt,name=Writer,proto3" json:"Writer,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto1.CompactTextString(m) }
func (*State) ProtoMessage()    {}

type Conf struct {
	This uint32 `protobuf:"varint,1,opt,name=This,proto3" json:"This,omitempty"`
	Cur  uint32 `protobuf:"varint,2,opt,name=Cur,proto3" json:"Cur,omitempty"`
}

func (m *Conf) Reset()         { *m = Conf{} }
func (m *Conf) String() string { return proto1.CompactTextString(m) }
func (*Conf) ProtoMessage()    {}

type ConfReply struct {
	Cur   *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Abort bool         `protobuf:"varint,2,opt,name=Abort,proto3" json:"Abort,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *ConfReply) Reset()         { *m = ConfReply{} }
func (m *ConfReply) String() string { return proto1.CompactTextString(m) }
func (*ConfReply) ProtoMessage()    {}

func (m *ConfReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *ConfReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type Node struct {
	Id      uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Version uint32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto1.CompactTextString(m) }
func (*Node) ProtoMessage()    {}

type Blueprint struct {
	Nodes          []*Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	FaultTolerance uint32  `protobuf:"varint,3,opt,name=FaultTolerance,proto3" json:"FaultTolerance,omitempty"`
	Epoch          uint32  `protobuf:"varint,4,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
}

func (m *Blueprint) Reset()         { *m = Blueprint{} }
func (m *Blueprint) String() string { return proto1.CompactTextString(m) }
func (*Blueprint) ProtoMessage()    {}

func (m *Blueprint) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type NewCur struct {
	Cur  *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	CurC uint32     `protobuf:"varint,2,opt,name=CurC,proto3" json:"CurC,omitempty"`
}

func (m *NewCur) Reset()         { *m = NewCur{} }
func (m *NewCur) String() string { return proto1.CompactTextString(m) }
func (*NewCur) ProtoMessage()    {}

func (m *NewCur) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type NewCurReply struct {
	New bool `protobuf:"varint,1,opt,name=New,proto3" json:"New,omitempty"`
}

func (m *NewCurReply) Reset()         { *m = NewCurReply{} }
func (m *NewCurReply) String() string { return proto1.CompactTextString(m) }
func (*NewCurReply) ProtoMessage()    {}

type Read struct {
	Conf *Conf `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *Read) Reset()         { *m = Read{} }
func (m *Read) String() string { return proto1.CompactTextString(m) }
func (*Read) ProtoMessage()    {}

func (m *Read) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type ReadReply struct {
	State *State     `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *ConfReply `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *ReadReply) Reset()         { *m = ReadReply{} }
func (m *ReadReply) String() string { return proto1.CompactTextString(m) }
func (*ReadReply) ProtoMessage()    {}

func (m *ReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ReadReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

type WriteS struct {
	State *State `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Conf  *Conf  `protobuf:"bytes,2,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *WriteS) Reset()         { *m = WriteS{} }
func (m *WriteS) String() string { return proto1.CompactTextString(m) }
func (*WriteS) ProtoMessage()    {}

func (m *WriteS) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteS) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type AdvRead struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
}

func (m *AdvRead) Reset()         { *m = AdvRead{} }
func (m *AdvRead) String() string { return proto1.CompactTextString(m) }
func (*AdvRead) ProtoMessage()    {}

type AdvReadReply struct {
	State *State       `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *Blueprint   `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *AdvReadReply) Reset()         { *m = AdvReadReply{} }
func (m *AdvReadReply) String() string { return proto1.CompactTextString(m) }
func (*AdvReadReply) ProtoMessage()    {}

func (m *AdvReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *AdvReadReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *AdvReadReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type AdvWriteS struct {
	State *State `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	CurC  uint32 `protobuf:"varint,2,opt,name=CurC,proto3" json:"CurC,omitempty"`
}

func (m *AdvWriteS) Reset()         { *m = AdvWriteS{} }
func (m *AdvWriteS) String() string { return proto1.CompactTextString(m) }
func (*AdvWriteS) ProtoMessage()    {}

func (m *AdvWriteS) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type AdvWriteSReply struct {
	Cur  *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *AdvWriteSReply) Reset()         { *m = AdvWriteSReply{} }
func (m *AdvWriteSReply) String() string { return proto1.CompactTextString(m) }
func (*AdvWriteSReply) ProtoMessage()    {}

func (m *AdvWriteSReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *AdvWriteSReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteN struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Next *Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *WriteN) Reset()         { *m = WriteN{} }
func (m *WriteN) String() string { return proto1.CompactTextString(m) }
func (*WriteN) ProtoMessage()    {}

func (m *WriteN) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteNReply struct {
	Cur     *ConfReply `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	State   *State     `protobuf:"bytes,2,opt,name=State" json:"State,omitempty"`
	LAState *Blueprint `protobuf:"bytes,3,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *WriteNReply) Reset()         { *m = WriteNReply{} }
func (m *WriteNReply) String() string { return proto1.CompactTextString(m) }
func (*WriteNReply) ProtoMessage()    {}

func (m *WriteNReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *WriteNReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteNReply) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type LAProposal struct {
	Conf *Conf      `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Prop *Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *LAProposal) Reset()         { *m = LAProposal{} }
func (m *LAProposal) String() string { return proto1.CompactTextString(m) }
func (*LAProposal) ProtoMessage()    {}

func (m *LAProposal) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *LAProposal) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type LAReply struct {
	Cur     *ConfReply `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	LAState *Blueprint `protobuf:"bytes,2,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *LAReply) Reset()         { *m = LAReply{} }
func (m *LAReply) String() string { return proto1.CompactTextString(m) }
func (*LAReply) ProtoMessage()    {}

func (m *LAReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *LAReply) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewState struct {
	CurC    uint32     `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Cur     *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	State   *State     `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
	LAState *Blueprint `protobuf:"bytes,4,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *NewState) Reset()         { *m = NewState{} }
func (m *NewState) String() string { return proto1.CompactTextString(m) }
func (*NewState) ProtoMessage()    {}

func (m *NewState) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewState) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NewState) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewStateReply struct {
	Cur  *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *NewStateReply) Reset()         { *m = NewStateReply{} }
func (m *NewStateReply) String() string { return proto1.CompactTextString(m) }
func (*NewStateReply) ProtoMessage()    {}

func (m *NewStateReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewStateReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type DRead struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Prop *Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *DRead) Reset()         { *m = DRead{} }
func (m *DRead) String() string { return proto1.CompactTextString(m) }
func (*DRead) ProtoMessage()    {}

func (m *DRead) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type DWriteN struct {
	CurC uint32       `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *DWriteN) Reset()         { *m = DWriteN{} }
func (m *DWriteN) String() string { return proto1.CompactTextString(m) }
func (*DWriteN) ProtoMessage()    {}

func (m *DWriteN) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type DWriteNReply struct {
	Cur *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *DWriteNReply) Reset()         { *m = DWriteNReply{} }
func (m *DWriteNReply) String() string { return proto1.CompactTextString(m) }
func (*DWriteNReply) ProtoMessage()    {}

func (m *DWriteNReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type GetOne struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Next *Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *GetOne) Reset()         { *m = GetOne{} }
func (m *GetOne) String() string { return proto1.CompactTextString(m) }
func (*GetOne) ProtoMessage()    {}

func (m *GetOne) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type GetOneReply struct {
	Next *Blueprint `protobuf:"bytes,1,opt,name=Next" json:"Next,omitempty"`
	Cur  *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *GetOneReply) Reset()         { *m = GetOneReply{} }
func (m *GetOneReply) String() string { return proto1.CompactTextString(m) }
func (*GetOneReply) ProtoMessage()    {}

func (m *GetOneReply) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *GetOneReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type CV struct {
	Rnd uint32     `protobuf:"varint,1,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Val *Blueprint `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *CV) Reset()         { *m = CV{} }
func (m *CV) String() string { return proto1.CompactTextString(m) }
func (*CV) ProtoMessage()    {}

func (m *CV) GetVal() *Blueprint {
	if m != nil {
		return m.Val
	}
	return nil
}

type Prepare struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Rnd  uint32 `protobuf:"varint,2,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto1.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}

type Promise struct {
	Cur *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Rnd uint32     `protobuf:"varint,2,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Val *CV        `protobuf:"bytes,3,opt,name=Val" json:"Val,omitempty"`
	Dec *Blueprint `protobuf:"bytes,4,opt,name=Dec" json:"Dec,omitempty"`
}

func (m *Promise) Reset()         { *m = Promise{} }
func (m *Promise) String() string { return proto1.CompactTextString(m) }
func (*Promise) ProtoMessage()    {}

func (m *Promise) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Promise) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Promise) GetDec() *Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

type Propose struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Val  *CV    `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *Propose) Reset()         { *m = Propose{} }
func (m *Propose) String() string { return proto1.CompactTextString(m) }
func (*Propose) ProtoMessage()    {}

func (m *Propose) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

type Learn struct {
	Cur     *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Dec     *Blueprint `protobuf:"bytes,2,opt,name=Dec" json:"Dec,omitempty"`
	Learned bool       `protobuf:"varint,3,opt,name=Learned,proto3" json:"Learned,omitempty"`
}

func (m *Learn) Reset()         { *m = Learn{} }
func (m *Learn) String() string { return proto1.CompactTextString(m) }
func (*Learn) ProtoMessage()    {}

func (m *Learn) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Learn) GetDec() *Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

func init() {
	proto1.RegisterType((*State)(nil), "proto.State")
	proto1.RegisterType((*Conf)(nil), "proto.Conf")
	proto1.RegisterType((*ConfReply)(nil), "proto.ConfReply")
	proto1.RegisterType((*Node)(nil), "proto.Node")
	proto1.RegisterType((*Blueprint)(nil), "proto.Blueprint")
	proto1.RegisterType((*NewCur)(nil), "proto.NewCur")
	proto1.RegisterType((*NewCurReply)(nil), "proto.NewCurReply")
	proto1.RegisterType((*Read)(nil), "proto.Read")
	proto1.RegisterType((*ReadReply)(nil), "proto.ReadReply")
	proto1.RegisterType((*WriteS)(nil), "proto.WriteS")
	proto1.RegisterType((*AdvRead)(nil), "proto.AdvRead")
	proto1.RegisterType((*AdvReadReply)(nil), "proto.AdvReadReply")
	proto1.RegisterType((*AdvWriteS)(nil), "proto.AdvWriteS")
	proto1.RegisterType((*AdvWriteSReply)(nil), "proto.AdvWriteSReply")
	proto1.RegisterType((*WriteN)(nil), "proto.WriteN")
	proto1.RegisterType((*WriteNReply)(nil), "proto.WriteNReply")
	proto1.RegisterType((*LAProposal)(nil), "proto.LAProposal")
	proto1.RegisterType((*LAReply)(nil), "proto.LAReply")
	proto1.RegisterType((*NewState)(nil), "proto.NewState")
	proto1.RegisterType((*NewStateReply)(nil), "proto.NewStateReply")
	proto1.RegisterType((*DRead)(nil), "proto.DRead")
	proto1.RegisterType((*DWriteN)(nil), "proto.DWriteN")
	proto1.RegisterType((*DWriteNReply)(nil), "proto.DWriteNReply")
	proto1.RegisterType((*GetOne)(nil), "proto.GetOne")
	proto1.RegisterType((*GetOneReply)(nil), "proto.GetOneReply")
	proto1.RegisterType((*CV)(nil), "proto.CV")
	proto1.RegisterType((*Prepare)(nil), "proto.Prepare")
	proto1.RegisterType((*Promise)(nil), "proto.Promise")
	proto1.RegisterType((*Propose)(nil), "proto.Propose")
	proto1.RegisterType((*Learn)(nil), "proto.Learn")
}

/* Manager type struct */

// Manager manages a pool of machine configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.RWMutex
	machines       []*Machine
	configs        []*Configuration
	machineGidToID map[uint32]int
	configGidToID  map[uint32]int
	closed         bool

	logger *log.Logger

	opts managerOptions

	aReadSqf     AReadSQuorumFn
	aWriteSqf    AWriteSQuorumFn
	aWriteNqf    AWriteNQuorumFn
	setCurqf     SetCurQuorumFn
	lAPropqf     LAPropQuorumFn
	setStateqf   SetStateQuorumFn
	getPromiseqf GetPromiseQuorumFn
	acceptqf     AcceptQuorumFn
	dReadSqf     DReadSQuorumFn
	dWriteSqf    DWriteSQuorumFn
	dWriteNSetqf DWriteNSetQuorumFn
	getOneNqf    GetOneNQuorumFn
	dSetCurqf    DSetCurQuorumFn
}

/* Manager quorum functions */

func (m *Manager) setDefaultQuorumFuncs() {
	if m.opts.aReadSqf != nil {
		m.aReadSqf = m.opts.aReadSqf
	} else {
		m.aReadSqf = func(c *Configuration, replies []*ReadReply) (*ReadReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.aWriteSqf != nil {
		m.aWriteSqf = m.opts.aWriteSqf
	} else {
		m.aWriteSqf = func(c *Configuration, replies []*ConfReply) (*ConfReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.aWriteNqf != nil {
		m.aWriteNqf = m.opts.aWriteNqf
	} else {
		m.aWriteNqf = func(c *Configuration, replies []*WriteNReply) (*WriteNReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.setCurqf != nil {
		m.setCurqf = m.opts.setCurqf
	} else {
		m.setCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.lAPropqf != nil {
		m.lAPropqf = m.opts.lAPropqf
	} else {
		m.lAPropqf = func(c *Configuration, replies []*LAReply) (*LAReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.setStateqf != nil {
		m.setStateqf = m.opts.setStateqf
	} else {
		m.setStateqf = func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.getPromiseqf != nil {
		m.getPromiseqf = m.opts.getPromiseqf
	} else {
		m.getPromiseqf = func(c *Configuration, replies []*Promise) (*Promise, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.acceptqf != nil {
		m.acceptqf = m.opts.acceptqf
	} else {
		m.acceptqf = func(c *Configuration, replies []*Learn) (*Learn, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dReadSqf != nil {
		m.dReadSqf = m.opts.dReadSqf
	} else {
		m.dReadSqf = func(c *Configuration, replies []*AdvReadReply) (*AdvReadReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dWriteSqf != nil {
		m.dWriteSqf = m.opts.dWriteSqf
	} else {
		m.dWriteSqf = func(c *Configuration, replies []*AdvWriteSReply) (*AdvWriteSReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dWriteNSetqf != nil {
		m.dWriteNSetqf = m.opts.dWriteNSetqf
	} else {
		m.dWriteNSetqf = func(c *Configuration, replies []*DWriteNReply) (*DWriteNReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.getOneNqf != nil {
		m.getOneNqf = m.opts.getOneNqf
	} else {
		m.getOneNqf = func(c *Configuration, replies []*GetOneReply) (*GetOneReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dSetCurqf != nil {
		m.dSetCurqf = m.opts.dSetCurqf
	} else {
		m.dSetCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
}

/* Manager create/close streams */

func (m *Manager) createStreamClients() error {
	if m.opts.noConnect {
		return nil
	}

	return nil
}

func (m *Manager) closeStreamClients() {
	if m.opts.noConnect {
		return
	}

}

/* Manager options */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool

	aReadSqf     AReadSQuorumFn
	aWriteSqf    AWriteSQuorumFn
	aWriteNqf    AWriteNQuorumFn
	setCurqf     SetCurQuorumFn
	lAPropqf     LAPropQuorumFn
	setStateqf   SetStateQuorumFn
	getPromiseqf GetPromiseQuorumFn
	acceptqf     AcceptQuorumFn
	dReadSqf     DReadSQuorumFn
	dWriteSqf    DWriteSQuorumFn
	dWriteNSetqf DWriteNSetQuorumFn
	getOneNqf    GetOneNQuorumFn
	dSetCurqf    DSetCurQuorumFn
}

// WithAReadSQuorumFunc returns a ManagerOption that sets a cumstom
// AReadSQuorumFunc.
func WithAReadSQuorumFunc(f AReadSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aReadSqf = f
	}
}

// WithAWriteSQuorumFunc returns a ManagerOption that sets a cumstom
// AWriteSQuorumFunc.
func WithAWriteSQuorumFunc(f AWriteSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aWriteSqf = f
	}
}

// WithAWriteNQuorumFunc returns a ManagerOption that sets a cumstom
// AWriteNQuorumFunc.
func WithAWriteNQuorumFunc(f AWriteNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aWriteNqf = f
	}
}

// WithSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// SetCurQuorumFunc.
func WithSetCurQuorumFunc(f SetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.setCurqf = f
	}
}

// WithLAPropQuorumFunc returns a ManagerOption that sets a cumstom
// LAPropQuorumFunc.
func WithLAPropQuorumFunc(f LAPropQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.lAPropqf = f
	}
}

// WithSetStateQuorumFunc returns a ManagerOption that sets a cumstom
// SetStateQuorumFunc.
func WithSetStateQuorumFunc(f SetStateQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.setStateqf = f
	}
}

// WithGetPromiseQuorumFunc returns a ManagerOption that sets a cumstom
// GetPromiseQuorumFunc.
func WithGetPromiseQuorumFunc(f GetPromiseQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.getPromiseqf = f
	}
}

// WithAcceptQuorumFunc returns a ManagerOption that sets a cumstom
// AcceptQuorumFunc.
func WithAcceptQuorumFunc(f AcceptQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.acceptqf = f
	}
}

// WithDReadSQuorumFunc returns a ManagerOption that sets a cumstom
// DReadSQuorumFunc.
func WithDReadSQuorumFunc(f DReadSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dReadSqf = f
	}
}

// WithDWriteSQuorumFunc returns a ManagerOption that sets a cumstom
// DWriteSQuorumFunc.
func WithDWriteSQuorumFunc(f DWriteSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dWriteSqf = f
	}
}

// WithDWriteNSetQuorumFunc returns a ManagerOption that sets a cumstom
// DWriteNSetQuorumFunc.
func WithDWriteNSetQuorumFunc(f DWriteNSetQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dWriteNSetqf = f
	}
}

// WithGetOneNQuorumFunc returns a ManagerOption that sets a cumstom
// GetOneNQuorumFunc.
func WithGetOneNQuorumFunc(f GetOneNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.getOneNqf = f
	}
}

// WithDSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// DSetCurQuorumFunc.
func WithDSetCurQuorumFunc(f DSetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dSetCurqf = f
	}
}

// AReadSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AReadSQuorumFn func(c *Configuration, replies []*ReadReply) (*ReadReply, bool)

// AWriteSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AWriteSQuorumFn func(c *Configuration, replies []*ConfReply) (*ConfReply, bool)

// AWriteNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AWriteNQuorumFn func(c *Configuration, replies []*WriteNReply) (*WriteNReply, bool)

// SetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

// LAPropQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type LAPropQuorumFn func(c *Configuration, replies []*LAReply) (*LAReply, bool)

// SetStateQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SetStateQuorumFn func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool)

// GetPromiseQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type GetPromiseQuorumFn func(c *Configuration, replies []*Promise) (*Promise, bool)

// AcceptQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AcceptQuorumFn func(c *Configuration, replies []*Learn) (*Learn, bool)

// DReadSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DReadSQuorumFn func(c *Configuration, replies []*AdvReadReply) (*AdvReadReply, bool)

// DWriteSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DWriteSQuorumFn func(c *Configuration, replies []*AdvWriteSReply) (*AdvWriteSReply, bool)

// DWriteNSetQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DWriteNSetQuorumFn func(c *Configuration, replies []*DWriteNReply) (*DWriteNReply, bool)

// GetOneNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type GetOneNQuorumFn func(c *Configuration, replies []*GetOneReply) (*GetOneReply, bool)

// DSetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DSetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

/* Gorums Client API */

/* Configuration RPC specific */

// AReadSReply encapsulates the reply from a AReadS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AReadSReply struct {
	MachineIDs []int
	Reply      *ReadReply
}

func (r AReadSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AReadSReply invokes a AReadS RPC on configuration c
// and returns the result as a AReadSReply.
func (c *Configuration) AReadS(args *Conf) (*AReadSReply, error) {
	return c.mgr.aReadS(c.id, args)
}

// AReadSFuture is a reference to an asynchronous AReadS RPC invocation.
type AReadSFuture struct {
	reply *AReadSReply
	err   error
	c     chan struct{}
}

// AReadSFuture asynchronously invokes a AReadS RPC on configuration c and
// returns a AReadSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AReadSFuture(args *Conf) *AReadSFuture {
	f := new(AReadSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aReadS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AReadSFuture.
// The method blocks until a reply or error is available.
func (f *AReadSFuture) Get() (*AReadSReply, error) {
	<-f.c
	return f.reply, f.err
}

// AWriteSReply encapsulates the reply from a AWriteS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AWriteSReply struct {
	MachineIDs []int
	Reply      *ConfReply
}

func (r AWriteSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AWriteSReply invokes a AWriteS RPC on configuration c
// and returns the result as a AWriteSReply.
func (c *Configuration) AWriteS(args *WriteS) (*AWriteSReply, error) {
	return c.mgr.aWriteS(c.id, args)
}

// AWriteSFuture is a reference to an asynchronous AWriteS RPC invocation.
type AWriteSFuture struct {
	reply *AWriteSReply
	err   error
	c     chan struct{}
}

// AWriteSFuture asynchronously invokes a AWriteS RPC on configuration c and
// returns a AWriteSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AWriteSFuture(args *WriteS) *AWriteSFuture {
	f := new(AWriteSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aWriteS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AWriteSFuture.
// The method blocks until a reply or error is available.
func (f *AWriteSFuture) Get() (*AWriteSReply, error) {
	<-f.c
	return f.reply, f.err
}

// AWriteNReply encapsulates the reply from a AWriteN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AWriteNReply struct {
	MachineIDs []int
	Reply      *WriteNReply
}

func (r AWriteNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AWriteNReply invokes a AWriteN RPC on configuration c
// and returns the result as a AWriteNReply.
func (c *Configuration) AWriteN(args *WriteN) (*AWriteNReply, error) {
	return c.mgr.aWriteN(c.id, args)
}

// AWriteNFuture is a reference to an asynchronous AWriteN RPC invocation.
type AWriteNFuture struct {
	reply *AWriteNReply
	err   error
	c     chan struct{}
}

// AWriteNFuture asynchronously invokes a AWriteN RPC on configuration c and
// returns a AWriteNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AWriteNFuture(args *WriteN) *AWriteNFuture {
	f := new(AWriteNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aWriteN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AWriteNFuture.
// The method blocks until a reply or error is available.
func (f *AWriteNFuture) Get() (*AWriteNReply, error) {
	<-f.c
	return f.reply, f.err
}

// SetCurReply encapsulates the reply from a SetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SetCurReply struct {
	MachineIDs []int
	Reply      *NewCurReply
}

func (r SetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SetCurReply invokes a SetCur RPC on configuration c
// and returns the result as a SetCurReply.
func (c *Configuration) SetCur(args *NewCur) (*SetCurReply, error) {
	return c.mgr.setCur(c.id, args)
}

// SetCurFuture is a reference to an asynchronous SetCur RPC invocation.
type SetCurFuture struct {
	reply *SetCurReply
	err   error
	c     chan struct{}
}

// SetCurFuture asynchronously invokes a SetCur RPC on configuration c and
// returns a SetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SetCurFuture(args *NewCur) *SetCurFuture {
	f := new(SetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.setCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SetCurFuture.
// The method blocks until a reply or error is available.
func (f *SetCurFuture) Get() (*SetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

// LAPropReply encapsulates the reply from a LAProp RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type LAPropReply struct {
	MachineIDs []int
	Reply      *LAReply
}

func (r LAPropReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// LAPropReply invokes a LAProp RPC on configuration c
// and returns the result as a LAPropReply.
func (c *Configuration) LAProp(args *LAProposal) (*LAPropReply, error) {
	return c.mgr.lAProp(c.id, args)
}

// LAPropFuture is a reference to an asynchronous LAProp RPC invocation.
type LAPropFuture struct {
	reply *LAPropReply
	err   error
	c     chan struct{}
}

// LAPropFuture asynchronously invokes a LAProp RPC on configuration c and
// returns a LAPropFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) LAPropFuture(args *LAProposal) *LAPropFuture {
	f := new(LAPropFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.lAProp(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the LAPropFuture.
// The method blocks until a reply or error is available.
func (f *LAPropFuture) Get() (*LAPropReply, error) {
	<-f.c
	return f.reply, f.err
}

// SetStateReply encapsulates the reply from a SetState RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SetStateReply struct {
	MachineIDs []int
	Reply      *NewStateReply
}

func (r SetStateReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SetStateReply invokes a SetState RPC on configuration c
// and returns the result as a SetStateReply.
func (c *Configuration) SetState(args *NewState) (*SetStateReply, error) {
	return c.mgr.setState(c.id, args)
}

// SetStateFuture is a reference to an asynchronous SetState RPC invocation.
type SetStateFuture struct {
	reply *SetStateReply
	err   error
	c     chan struct{}
}

// SetStateFuture asynchronously invokes a SetState RPC on configuration c and
// returns a SetStateFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SetStateFuture(args *NewState) *SetStateFuture {
	f := new(SetStateFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.setState(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SetStateFuture.
// The method blocks until a reply or error is available.
func (f *SetStateFuture) Get() (*SetStateReply, error) {
	<-f.c
	return f.reply, f.err
}

// GetPromiseReply encapsulates the reply from a GetPromise RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type GetPromiseReply struct {
	MachineIDs []int
	Reply      *Promise
}

func (r GetPromiseReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// GetPromiseReply invokes a GetPromise RPC on configuration c
// and returns the result as a GetPromiseReply.
func (c *Configuration) GetPromise(args *Prepare) (*GetPromiseReply, error) {
	return c.mgr.getPromise(c.id, args)
}

// GetPromiseFuture is a reference to an asynchronous GetPromise RPC invocation.
type GetPromiseFuture struct {
	reply *GetPromiseReply
	err   error
	c     chan struct{}
}

// GetPromiseFuture asynchronously invokes a GetPromise RPC on configuration c and
// returns a GetPromiseFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) GetPromiseFuture(args *Prepare) *GetPromiseFuture {
	f := new(GetPromiseFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.getPromise(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the GetPromiseFuture.
// The method blocks until a reply or error is available.
func (f *GetPromiseFuture) Get() (*GetPromiseReply, error) {
	<-f.c
	return f.reply, f.err
}

// AcceptReply encapsulates the reply from a Accept RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AcceptReply struct {
	MachineIDs []int
	Reply      *Learn
}

func (r AcceptReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AcceptReply invokes a Accept RPC on configuration c
// and returns the result as a AcceptReply.
func (c *Configuration) Accept(args *Propose) (*AcceptReply, error) {
	return c.mgr.accept(c.id, args)
}

// AcceptFuture is a reference to an asynchronous Accept RPC invocation.
type AcceptFuture struct {
	reply *AcceptReply
	err   error
	c     chan struct{}
}

// AcceptFuture asynchronously invokes a Accept RPC on configuration c and
// returns a AcceptFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AcceptFuture(args *Propose) *AcceptFuture {
	f := new(AcceptFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.accept(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AcceptFuture.
// The method blocks until a reply or error is available.
func (f *AcceptFuture) Get() (*AcceptReply, error) {
	<-f.c
	return f.reply, f.err
}

// DReadSReply encapsulates the reply from a DReadS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DReadSReply struct {
	MachineIDs []int
	Reply      *AdvReadReply
}

func (r DReadSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DReadSReply invokes a DReadS RPC on configuration c
// and returns the result as a DReadSReply.
func (c *Configuration) DReadS(args *DRead) (*DReadSReply, error) {
	return c.mgr.dReadS(c.id, args)
}

// DReadSFuture is a reference to an asynchronous DReadS RPC invocation.
type DReadSFuture struct {
	reply *DReadSReply
	err   error
	c     chan struct{}
}

// DReadSFuture asynchronously invokes a DReadS RPC on configuration c and
// returns a DReadSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DReadSFuture(args *DRead) *DReadSFuture {
	f := new(DReadSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dReadS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DReadSFuture.
// The method blocks until a reply or error is available.
func (f *DReadSFuture) Get() (*DReadSReply, error) {
	<-f.c
	return f.reply, f.err
}

// DWriteSReply encapsulates the reply from a DWriteS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DWriteSReply struct {
	MachineIDs []int
	Reply      *AdvWriteSReply
}

func (r DWriteSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DWriteSReply invokes a DWriteS RPC on configuration c
// and returns the result as a DWriteSReply.
func (c *Configuration) DWriteS(args *AdvWriteS) (*DWriteSReply, error) {
	return c.mgr.dWriteS(c.id, args)
}

// DWriteSFuture is a reference to an asynchronous DWriteS RPC invocation.
type DWriteSFuture struct {
	reply *DWriteSReply
	err   error
	c     chan struct{}
}

// DWriteSFuture asynchronously invokes a DWriteS RPC on configuration c and
// returns a DWriteSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DWriteSFuture(args *AdvWriteS) *DWriteSFuture {
	f := new(DWriteSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dWriteS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DWriteSFuture.
// The method blocks until a reply or error is available.
func (f *DWriteSFuture) Get() (*DWriteSReply, error) {
	<-f.c
	return f.reply, f.err
}

// DWriteNSetReply encapsulates the reply from a DWriteNSet RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DWriteNSetReply struct {
	MachineIDs []int
	Reply      *DWriteNReply
}

func (r DWriteNSetReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DWriteNSetReply invokes a DWriteNSet RPC on configuration c
// and returns the result as a DWriteNSetReply.
func (c *Configuration) DWriteNSet(args *DWriteN) (*DWriteNSetReply, error) {
	return c.mgr.dWriteNSet(c.id, args)
}

// DWriteNSetFuture is a reference to an asynchronous DWriteNSet RPC invocation.
type DWriteNSetFuture struct {
	reply *DWriteNSetReply
	err   error
	c     chan struct{}
}

// DWriteNSetFuture asynchronously invokes a DWriteNSet RPC on configuration c and
// returns a DWriteNSetFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DWriteNSetFuture(args *DWriteN) *DWriteNSetFuture {
	f := new(DWriteNSetFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dWriteNSet(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DWriteNSetFuture.
// The method blocks until a reply or error is available.
func (f *DWriteNSetFuture) Get() (*DWriteNSetReply, error) {
	<-f.c
	return f.reply, f.err
}

// GetOneNReply encapsulates the reply from a GetOneN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type GetOneNReply struct {
	MachineIDs []int
	Reply      *GetOneReply
}

func (r GetOneNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// GetOneNReply invokes a GetOneN RPC on configuration c
// and returns the result as a GetOneNReply.
func (c *Configuration) GetOneN(args *GetOne) (*GetOneNReply, error) {
	return c.mgr.getOneN(c.id, args)
}

// GetOneNFuture is a reference to an asynchronous GetOneN RPC invocation.
type GetOneNFuture struct {
	reply *GetOneNReply
	err   error
	c     chan struct{}
}

// GetOneNFuture asynchronously invokes a GetOneN RPC on configuration c and
// returns a GetOneNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) GetOneNFuture(args *GetOne) *GetOneNFuture {
	f := new(GetOneNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.getOneN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the GetOneNFuture.
// The method blocks until a reply or error is available.
func (f *GetOneNFuture) Get() (*GetOneNReply, error) {
	<-f.c
	return f.reply, f.err
}

// DSetCurReply encapsulates the reply from a DSetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DSetCurReply struct {
	MachineIDs []int
	Reply      *NewCurReply
}

func (r DSetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DSetCurReply invokes a DSetCur RPC on configuration c
// and returns the result as a DSetCurReply.
func (c *Configuration) DSetCur(args *NewCur) (*DSetCurReply, error) {
	return c.mgr.dSetCur(c.id, args)
}

// DSetCurFuture is a reference to an asynchronous DSetCur RPC invocation.
type DSetCurFuture struct {
	reply *DSetCurReply
	err   error
	c     chan struct{}
}

// DSetCurFuture asynchronously invokes a DSetCur RPC on configuration c and
// returns a DSetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DSetCurFuture(args *NewCur) *DSetCurFuture {
	f := new(DSetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dSetCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DSetCurFuture.
// The method blocks until a reply or error is available.
func (f *DSetCurFuture) Get() (*DSetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

/* Manager RPC specific */

type aReadSReply struct {
	mid   int
	reply *ReadReply
	err   error
}

func (m *Manager) aReadS(cid int, args *Conf) (*AReadSReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan aReadSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*ReadReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AReadSReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(ReadReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/AReadS",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aReadSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.aReadSqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type aWriteSReply struct {
	mid   int
	reply *ConfReply
	err   error
}

func (m *Manager) aWriteS(cid int, args *WriteS) (*AWriteSReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan aWriteSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*ConfReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AWriteSReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(ConfReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/AWriteS",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aWriteSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.aWriteSqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type aWriteNReply struct {
	mid   int
	reply *WriteNReply
	err   error
}

func (m *Manager) aWriteN(cid int, args *WriteN) (*AWriteNReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan aWriteNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*WriteNReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AWriteNReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(WriteNReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/AWriteN",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aWriteNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.aWriteNqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type setCurReply struct {
	mid   int
	reply *NewCurReply
	err   error
}

func (m *Manager) setCur(cid int, args *NewCur) (*SetCurReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan setCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SetCurReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/SetCur",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- setCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.setCurqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type lAPropReply struct {
	mid   int
	reply *LAReply
	err   error
}

func (m *Manager) lAProp(cid int, args *LAProposal) (*LAPropReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan lAPropReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*LAReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &LAPropReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(LAReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/LAProp",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- lAPropReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.lAPropqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type setStateReply struct {
	mid   int
	reply *NewStateReply
	err   error
}

func (m *Manager) setState(cid int, args *NewState) (*SetStateReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan setStateReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewStateReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SetStateReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewStateReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/SetState",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- setStateReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.setStateqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type getPromiseReply struct {
	mid   int
	reply *Promise
	err   error
}

func (m *Manager) getPromise(cid int, args *Prepare) (*GetPromiseReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan getPromiseReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Promise, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &GetPromiseReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(Promise)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/GetPromise",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- getPromiseReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.getPromiseqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type acceptReply struct {
	mid   int
	reply *Learn
	err   error
}

func (m *Manager) accept(cid int, args *Propose) (*AcceptReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan acceptReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Learn, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AcceptReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(Learn)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/Accept",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- acceptReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.acceptqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dReadSReply struct {
	mid   int
	reply *AdvReadReply
	err   error
}

func (m *Manager) dReadS(cid int, args *DRead) (*DReadSReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dReadSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*AdvReadReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DReadSReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(AdvReadReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DReadS",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dReadSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dReadSqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dWriteSReply struct {
	mid   int
	reply *AdvWriteSReply
	err   error
}

func (m *Manager) dWriteS(cid int, args *AdvWriteS) (*DWriteSReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dWriteSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*AdvWriteSReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DWriteSReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(AdvWriteSReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DWriteS",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dWriteSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dWriteSqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dWriteNSetReply struct {
	mid   int
	reply *DWriteNReply
	err   error
}

func (m *Manager) dWriteNSet(cid int, args *DWriteN) (*DWriteNSetReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dWriteNSetReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*DWriteNReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DWriteNSetReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(DWriteNReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DWriteNSet",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dWriteNSetReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dWriteNSetqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type getOneNReply struct {
	mid   int
	reply *GetOneReply
	err   error
}

func (m *Manager) getOneN(cid int, args *GetOne) (*GetOneNReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan getOneNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*GetOneReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &GetOneNReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(GetOneReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/GetOneN",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- getOneNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.getOneNqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dSetCurReply struct {
	mid   int
	reply *NewCurReply
	err   error
}

func (m *Manager) dSetCur(cid int, args *NewCur) (*DSetCurReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dSetCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DSetCurReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DSetCur",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dSetCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dSetCurqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of machines on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id       int
	gid      uint32
	machines []int
	mgr      *Manager
	quorum   int
	timeout  time.Duration
	defCtx   context.Context
}

// ID reports the local identifier for the configuration.
func (c *Configuration) ID() int {
	return c.id
}

// GlobalID reports the unique global identifier for the configuration.
func (c *Configuration) GlobalID() uint32 {
	return c.gid
}

// Machines returns a slice containing the local ids of all the machines in the
// configuration.
func (c *Configuration) Machines() []int { return c.machines }

// Quorum returns the quourm size for the configuration.
func (c *Configuration) Quorum() int {
	return c.quorum
}

// Size returns the number of machines in the configuration.
func (c *Configuration) Size() int {
	return len(c.machines)
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d | gid: %d", c.id, c.gid)
}

// Equal retuns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.gid == b.gid }

/* errors.go */

// A MachineNotFoundError reports that a specified machine could not be found.
type MachineNotFoundError uint32

func (e MachineNotFoundError) Error() string {
	return fmt.Sprintf("machine not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, RepliesCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.RepliesCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited                 time.Duration
	ErrCount, RepliesCount int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

/* machine.go */

// Machine encapsulates the state of a machine on which a remote procedure call
// can be made.
type Machine struct {
	// Only assigned at creation.
	id   int
	gid  uint32
	addr string
	conn *grpc.ClientConn

	sync.Mutex
	lastErr error
	latency time.Duration
}

// ConnState returns the state of the underlying gRPC client connection.
func (m *Machine) ConnState() grpc.ConnectivityState {
	return m.conn.State()
}

func (m *Machine) String() string {
	m.Lock()
	defer m.Unlock()
	return fmt.Sprintf(
		"machine %d | gid: %d | addr: %s | latency: %v | connstate: %v",
		m.id,
		m.gid,
		m.addr,
		m.latency,
		m.conn.State(),
	)
}

func (m *Machine) setLastErr(err error) {
	m.Lock()
	defer m.Unlock()
	m.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this machine.
func (m *Machine) LastErr() error {
	m.Lock()
	defer m.Unlock()
	return m.lastErr
}

func (m *Machine) setLatency(lat time.Duration) {
	m.Lock()
	defer m.Unlock()
	m.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this machine.
func (m *Machine) Latency() time.Duration {
	m.Lock()
	defer m.Unlock()
	return m.latency
}

// ByID attaches the methods of sort.Interface to []Machine, sorting machines
// by their local identifier in increasing order.
type ByID []*Machine

func (p ByID) Len() int           { return len(p) }
func (p ByID) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
func (p ByID) Less(i, j int) bool { return p[i].id < p[j].id }

// ByGID attaches the methods of sort.Interface to []Machine, sorting machines
// by their global identifier in increasing order.
type ByGID []*Machine

func (p ByGID) Len() int           { return len(p) }
func (p ByGID) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
func (p ByGID) Less(i, j int) bool { return p[i].gid < p[j].gid }

// ByLatency attaches the methods of sort.Interface to []Machine, sorting
// machines by latency in increasing order. Latencies less then zero (sentinel
// value) are considered greater than any positive latency.
type ByLatency []*Machine

func (p ByLatency) Len() int      { return len(p) }
func (p ByLatency) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p ByLatency) Less(i, j int) bool {
	if p[i].latency < 0 {
		return false
	}
	return p[i].latency < p[j].latency
}

/* mgr.go */

// NewManager attempts to connect to the given machines, and returns a new
// Manager containing those machines if successful.
func NewManager(machines []string, opts ...ManagerOption) (*Manager, error) {
	if len(machines) == 0 {
		return nil, fmt.Errorf("could not create manager: no machines provided")
	}

	m := new(Manager)
	m.machineGidToID = make(map[uint32]int)
	m.configGidToID = make(map[uint32]int)

	for _, opt := range opts {
		opt(&m.opts)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	for _, mn := range machines {
		err := m.createMachine(mn)
		if err != nil {
			return nil, fmt.Errorf("could not create manager: %v", err)
		}
	}

	err := m.createStreamClients()
	if err != nil {
		return nil, fmt.Errorf("could not create manager: %v", err)
	}

	m.setDefaultQuorumFuncs()

	return m, nil
}

// Close closes all machine connections and any client streams.
func (m *Manager) Close() error {
	m.Lock()
	defer m.Unlock()
	if m.closed {
		return errors.New("manager already closed")
	}
	m.closed = true
	m.closeStreamClients()
	err := m.closeMachineConns()
	if err != nil {
		return err
	}
	return nil
}

// MachineIDs returns the identifier of each available machine.
func (m *Manager) MachineIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.machines))
	for i := range m.machines {
		ids[i] = i
	}
	return ids
}

// MachineGlobalIDs returns the global identifier of each available machine.
func (m *Manager) MachineGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.machineGidToID))
	i := 0
	for gid := range m.machineGidToID {
		gids[i] = gid
		i++
	}
	return gids
}

// Machine returns the machine with the given local identifier if present.
func (m *Manager) Machine(id int) (machine *Machine, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.machines) {
		return nil, false
	}
	machine = m.machines[id]
	if machine == nil {
		return nil, false
	}
	return machine, true
}

// MachineFromGlobalID returns the machine with the given global identifier if
// present.
func (m *Manager) MachineFromGlobalID(gid uint32) (machine *Machine, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.machineGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Machine(localID)
}

// Machines returns a slice of each available machine.
func (m *Manager) Machines() []*Machine {
	m.RLock()
	defer m.RUnlock()
	mas := make([]*Machine, len(m.machines))
	for i := range m.machines {
		mas[i] = m.machines[i]
	}
	return mas
}

// ConfigurationIDs returns the identifier of each available configuration.
func (m *Manager) ConfigurationIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.configs))
	for i := range m.configs {
		ids[i] = i
	}
	return ids
}

// ConfigurationGlobalIDs returns the global identifier of each available
// configuration.
func (m *Manager) ConfigurationGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.configGidToID))
	i := 0
	for gid := range m.configGidToID {
		gids[i] = gid
		i++
	}
	return gids
}

// Configuration returns the configuration with the given identifier if
// present.
func (m *Manager) Configuration(id int) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.configs) {
		return nil, false
	}
	config = m.configs[id]
	if config == nil {
		return nil, false
	}
	return config, true
}

// ConfigurationFromGlobalID returns the configuration with the given global
// identifier if present.
func (m *Manager) ConfigurationFromGlobalID(gid uint32) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.configGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Configuration(localID)
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.RLock()
	defer m.RUnlock()
	cos := make([]*Configuration, len(m.configs))
	for i := range m.configs {
		cos[i] = m.configs[i]
	}
	return cos
}

// Size returns the number of machines and configurations in the Manager.
func (m *Manager) Size() (machines, configs int) {
	m.RLock()
	defer m.RUnlock()
	return len(m.machines), len(m.configs)
}

// AddMachine attempts to dial to the provide machine address. The machine is
// added to the Manager's pool of machines if a connection was established.
func (m *Manager) AddMachine(addr string) error {
	return m.createMachine(addr)
}

func (m *Manager) createMachine(mn string) error {
	m.Lock()
	defer m.Unlock()
	h := fnv.New32a()
	h.Write([]byte(mn))
	gid := h.Sum32()
	if _, machineExists := m.machineGidToID[gid]; machineExists {
		return fmt.Errorf("create machine %s error: machine already exists", mn)
	}
	id := len(m.machines)

	ma := &Machine{
		id:      id,
		gid:     gid,
		addr:    mn,
		latency: -1 * time.Second,
	}

	err := m.connect(ma)
	if err != nil {
		return fmt.Errorf("create machine %s error: %v", mn, err)
	}

	m.machines = append(m.machines, ma)
	m.machineGidToID[gid] = id

	return nil
}

func (m *Manager) connect(ma *Machine) error {
	if m.opts.noConnect {
		return nil
	}

	conn, err := grpc.Dial(ma.addr, m.opts.grpcDialOpts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}
	ma.conn = conn

	return nil
}

func (m *Manager) closeMachineConns() error {
	for _, machine := range m.machines {
		err := machine.conn.Close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("machine %d: error closing connection: %v", machine.id, err)
		}
	}
	return nil
}

// NewConfiguration returns a new configuration given a set of machine ids and
// a quorum size. Any given gRPC call options will be used for every RPC
// invocation on the configuration.
func (m *Manager) NewConfiguration(ids []int, quorumSize int, timeout time.Duration) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one machine")
	}
	if quorumSize > len(ids) || quorumSize < 1 {
		return nil, IllegalConfigError("invalid quourm size")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	var cmachines []*Machine
	for _, mid := range ids {
		if mid < 0 || mid >= len(m.machines) {
			return nil, MachineNotFoundError(mid)
		}
		machine := m.machines[mid]
		if machine == nil {
			return nil, MachineNotFoundError(mid)
		}
		cmachines = append(cmachines, machine)
	}

	// Machine ids are sorted by global id to
	// ensure a globally consistent configuration id.
	sort.Sort(ByGID(cmachines))

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, quorumSize)
	binary.Write(h, binary.LittleEndian, timeout)
	for _, machine := range cmachines {
		binary.Write(h, binary.LittleEndian, machine.gid)
	}
	gcid := h.Sum32()

	cid, found := m.configGidToID[gcid]
	if found {
		if m.configs[cid] == nil {
			panic(fmt.Sprintf("config with gcid %d and cid %d was nil", gcid, cid))
		}
		return m.configs[cid], nil
	}
	cid = len(m.configs)

	c := &Configuration{
		id:       cid,
		gid:      gcid,
		machines: ids,
		mgr:      m,
		quorum:   quorumSize,
		timeout:  timeout,
		defCtx:   context.Background(),
	}
	m.configs = append(m.configs, c)

	return c, nil
}

/* opts.go */

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each machine in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its machines .  the Manager. Mainly used for
// testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for AdvRegister service

type AdvRegisterClient interface {
	AReadS(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error)
	AWriteS(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*ConfReply, error)
	AWriteN(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error)
	SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
	LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error)
	SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error)
	GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error)
	Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error)
}

type advRegisterClient struct {
	cc *grpc.ClientConn
}

func NewAdvRegisterClient(cc *grpc.ClientConn) AdvRegisterClient {
	return &advRegisterClient{cc}
}

func (c *advRegisterClient) AReadS(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error) {
	out := new(ReadReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AReadS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) AWriteS(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*ConfReply, error) {
	out := new(ConfReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AWriteS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) AWriteN(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error) {
	out := new(WriteNReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AWriteN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/SetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error) {
	out := new(LAReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/LAProp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error) {
	out := new(NewStateReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/SetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error) {
	out := new(Promise)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/GetPromise", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error) {
	out := new(Learn)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/Accept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdvRegister service

type AdvRegisterServer interface {
	AReadS(context.Context, *Conf) (*ReadReply, error)
	AWriteS(context.Context, *WriteS) (*ConfReply, error)
	AWriteN(context.Context, *WriteN) (*WriteNReply, error)
	SetCur(context.Context, *NewCur) (*NewCurReply, error)
	LAProp(context.Context, *LAProposal) (*LAReply, error)
	SetState(context.Context, *NewState) (*NewStateReply, error)
	GetPromise(context.Context, *Prepare) (*Promise, error)
	Accept(context.Context, *Propose) (*Learn, error)
}

func RegisterAdvRegisterServer(s *grpc.Server, srv AdvRegisterServer) {
	s.RegisterService(&_AdvRegister_serviceDesc, srv)
}

func _AdvRegister_AReadS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Conf)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AReadS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_AWriteS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteS)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AWriteS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_AWriteN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AWriteN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_SetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).SetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_LAProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(LAProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).LAProp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewState)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).SetState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_GetPromise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Prepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).GetPromise(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Propose)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).Accept(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _AdvRegister_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AdvRegister",
	HandlerType: (*AdvRegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AReadS",
			Handler:    _AdvRegister_AReadS_Handler,
		},
		{
			MethodName: "AWriteS",
			Handler:    _AdvRegister_AWriteS_Handler,
		},
		{
			MethodName: "AWriteN",
			Handler:    _AdvRegister_AWriteN_Handler,
		},
		{
			MethodName: "SetCur",
			Handler:    _AdvRegister_SetCur_Handler,
		},
		{
			MethodName: "LAProp",
			Handler:    _AdvRegister_LAProp_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _AdvRegister_SetState_Handler,
		},
		{
			MethodName: "GetPromise",
			Handler:    _AdvRegister_GetPromise_Handler,
		},
		{
			MethodName: "Accept",
			Handler:    _AdvRegister_Accept_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for DynaDisk service

type DynaDiskClient interface {
	DReadS(ctx context.Context, in *DRead, opts ...grpc.CallOption) (*AdvReadReply, error)
	DWriteS(ctx context.Context, in *AdvWriteS, opts ...grpc.CallOption) (*AdvWriteSReply, error)
	DWriteNSet(ctx context.Context, in *DWriteN, opts ...grpc.CallOption) (*DWriteNReply, error)
	GetOneN(ctx context.Context, in *GetOne, opts ...grpc.CallOption) (*GetOneReply, error)
	DSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
}

type dynaDiskClient struct {
	cc *grpc.ClientConn
}

func NewDynaDiskClient(cc *grpc.ClientConn) DynaDiskClient {
	return &dynaDiskClient{cc}
}

func (c *dynaDiskClient) DReadS(ctx context.Context, in *DRead, opts ...grpc.CallOption) (*AdvReadReply, error) {
	out := new(AdvReadReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DReadS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DWriteS(ctx context.Context, in *AdvWriteS, opts ...grpc.CallOption) (*AdvWriteSReply, error) {
	out := new(AdvWriteSReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DWriteS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DWriteNSet(ctx context.Context, in *DWriteN, opts ...grpc.CallOption) (*DWriteNReply, error) {
	out := new(DWriteNReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DWriteNSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) GetOneN(ctx context.Context, in *GetOne, opts ...grpc.CallOption) (*GetOneReply, error) {
	out := new(GetOneReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/GetOneN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DSetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DynaDisk service

type DynaDiskServer interface {
	DReadS(context.Context, *DRead) (*AdvReadReply, error)
	DWriteS(context.Context, *AdvWriteS) (*AdvWriteSReply, error)
	DWriteNSet(context.Context, *DWriteN) (*DWriteNReply, error)
	GetOneN(context.Context, *GetOne) (*GetOneReply, error)
	DSetCur(context.Context, *NewCur) (*NewCurReply, error)
}

func RegisterDynaDiskServer(s *grpc.Server, srv DynaDiskServer) {
	s.RegisterService(&_DynaDisk_serviceDesc, srv)
}

func _DynaDisk_DReadS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DRead)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DReadS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DWriteS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AdvWriteS)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DWriteS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DWriteNSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DWriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DWriteNSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_GetOneN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetOne)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).GetOneN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DSetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DSetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _DynaDisk_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DynaDisk",
	HandlerType: (*DynaDiskServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DReadS",
			Handler:    _DynaDisk_DReadS_Handler,
		},
		{
			MethodName: "DWriteS",
			Handler:    _DynaDisk_DWriteS_Handler,
		},
		{
			MethodName: "DWriteNSet",
			Handler:    _DynaDisk_DWriteNSet_Handler,
		},
		{
			MethodName: "GetOneN",
			Handler:    _DynaDisk_GetOneN_Handler,
		},
		{
			MethodName: "DSetCur",
			Handler:    _DynaDisk_DSetCur_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *State) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *State) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	if m.Timestamp != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Timestamp))
	}
	if m.Writer != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Writer))
	}
	return i, nil
}

func (m *Conf) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Conf) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.This != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.This))
	}
	if m.Cur != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur))
	}
	return i, nil
}

func (m *ConfReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n1, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Abort {
		data[i] = 0x10
		i++
		if m.Abort {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x1a
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Id))
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Version))
	}
	return i, nil
}

func (m *Blueprint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Blueprint) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			data[i] = 0xa
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FaultTolerance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.FaultTolerance))
	}
	if m.Epoch != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Epoch))
	}
	return i, nil
}

func (m *NewCur) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewCur) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n2, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CurC != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	return i, nil
}

func (m *NewCurReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewCurReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.New {
		data[i] = 0x8
		i++
		if m.New {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Read) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Read) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n3, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ReadReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n4, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n5, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *WriteS) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteS) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n6, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Conf != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n7, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *AdvRead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdvRead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	return i, nil
}

func (m *AdvReadReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdvReadReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n8, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n9, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x1a
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AdvWriteS) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdvWriteS) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n10, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.CurC != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	return i, nil
}

func (m *AdvWriteSReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdvWriteSReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n11, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WriteN) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteN) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Next != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Next.Size()))
		n12, err := m.Next.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *WriteNReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteNReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n13, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.State != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n14, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.LAState != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.LAState.Size()))
		n15, err := m.LAState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *LAProposal) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LAProposal) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n16, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Prop != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Prop.Size()))
		n17, err := m.Prop.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *LAReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LAReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n18, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.LAState != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.LAState.Size()))
		n19, err := m.LAState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *NewState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n20, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.State != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n21, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.LAState != nil {
		data[i] = 0x22
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.LAState.Size()))
		n22, err := m.LAState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *NewStateReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewStateReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n23, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DRead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DRead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Prop != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Prop.Size()))
		n24, err := m.Prop.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *DWriteN) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DWriteN) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DWriteNReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DWriteNReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n25, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *GetOne) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetOne) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Next != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Next.Size()))
		n26, err := m.Next.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *GetOneReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetOneReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Next != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Next.Size()))
		n27, err := m.Next.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n28, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *CV) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CV) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Val.Size()))
		n29, err := m.Val.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *Prepare) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Prepare) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Rnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	return i, nil
}

func (m *Promise) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Promise) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n30, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Rnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Val.Size()))
		n31, err := m.Val.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Dec != nil {
		data[i] = 0x22
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Dec.Size()))
		n32, err := m.Dec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *Propose) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Propose) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Val != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Val.Size()))
		n33, err := m.Val.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *Learn) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Learn) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n34, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Dec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Dec.Size()))
		n35, err := m.Dec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Learned {
		data[i] = 0x18
		i++
		if m.Learned {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64DcSmartMerge(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32DcSmartMerge(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDcSmartMerge(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *State) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Timestamp))
	}
	if m.Writer != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Writer))
	}
	return n
}

func (m *Conf) Size() (n int) {
	var l int
	_ = l
	if m.This != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.This))
	}
	if m.Cur != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Cur))
	}
	return n
}

func (m *ConfReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Abort {
		n += 2
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Id))
	}
	if m.Version != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Version))
	}
	return n
}

func (m *Blueprint) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	if m.FaultTolerance != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.FaultTolerance))
	}
	if m.Epoch != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Epoch))
	}
	return n
}

func (m *NewCur) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	return n
}

func (m *NewCurReply) Size() (n int) {
	var l int
	_ = l
	if m.New {
		n += 2
	}
	return n
}

func (m *Read) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *ReadReply) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteS) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *AdvRead) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	return n
}

func (m *AdvReadReply) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *AdvWriteS) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	return n
}

func (m *AdvWriteSReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *WriteN) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteNReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *LAProposal) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *LAReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *NewState) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *NewStateReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *DRead) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *DWriteN) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *DWriteNReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *GetOne) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *GetOneReply) Size() (n int) {
	var l int
	_ = l
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *CV) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Prepare) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	return n
}

func (m *Promise) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Dec != nil {
		l = m.Dec.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Propose) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Learn) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Dec != nil {
		l = m.Dec.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Learned {
		n += 2
	}
	return n
}

func sovDcSmartMerge(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDcSmartMerge(x uint64) (n int) {
	return sovDcSmartMerge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *State) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writer", wireType)
			}
			m.Writer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Writer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Conf) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Conf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Conf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field This", wireType)
			}
			m.This = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.This |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			m.Cur = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cur |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Abort = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Blueprint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blueprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blueprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultTolerance", wireType)
			}
			m.FaultTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FaultTolerance |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewCur) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewCur: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewCur: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewCurReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewCurReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewCurReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.New = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Read) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Read: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Read: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteS) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvRead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvReadReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvReadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvReadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvWriteS) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvWriteS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvWriteS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvWriteSReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvWriteSReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvWriteSReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteN) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Blueprint{}
			}
			if err := m.Next.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteNReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteNReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteNReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &Blueprint{}
			}
			if err := m.LAState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LAProposal) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LAProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LAProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &Blueprint{}
			}
			if err := m.Prop.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LAReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LAReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LAReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &Blueprint{}
			}
			if err := m.LAState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &Blueprint{}
			}
			if err := m.LAState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewStateReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DRead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &Blueprint{}
			}
			if err := m.Prop.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DWriteN) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWriteN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWriteN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DWriteNReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWriteNReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWriteNReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOne) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOne: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOne: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Blueprint{}
			}
			if err := m.Next.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOneReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOneReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOneReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Blueprint{}
			}
			if err := m.Next.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CV) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Blueprint{}
			}
			if err := m.Val.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Promise) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Promise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Promise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &CV{}
			}
			if err := m.Val.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dec == nil {
				m.Dec = &Blueprint{}
			}
			if err := m.Dec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Propose) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Propose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Propose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &CV{}
			}
			if err := m.Val.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Learn) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Learn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Learn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dec == nil {
				m.Dec = &Blueprint{}
			}
			if err := m.Dec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDcSmartMerge(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDcSmartMerge
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDcSmartMerge
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDcSmartMerge(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDcSmartMerge = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDcSmartMerge   = fmt.Errorf("proto: integer overflow")
)
