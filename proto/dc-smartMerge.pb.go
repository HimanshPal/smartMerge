// Code generated by protoc-gen-go.
// source: dc-smartMerge.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	dc-smartMerge.proto

It has these top-level messages:
	State
	Conf
	ConfReply
	Node
	Blueprint
	NewCur
	NewCurReply
	Read
	ReadReply
	WriteS
	WriteSReply
	AdvRead
	AdvReadReply
	AdvWriteS
	AdvWriteSReply
	WriteN
	WriteNReply
	LAProposal
	LAReply
	NewState
	NewStateReply
	DRead
	DWriteN
	DWriteNReply
	GetOne
	GetOneReply
	CV
	Prepare
	Promise
	Propose
	Learn
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import (
	"encoding/binary"
	"hash/fnv"
	"sort"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type State struct {
	Value     []byte `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Timestamp int32  `protobuf:"varint,2,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Writer    uint32 `protobuf:"varint,3,opt,name=Writer" json:"Writer,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto1.CompactTextString(m) }
func (*State) ProtoMessage()    {}

type Conf struct {
	This uint32 `protobuf:"varint,1,opt,name=This" json:"This,omitempty"`
	Cur  uint32 `protobuf:"varint,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *Conf) Reset()         { *m = Conf{} }
func (m *Conf) String() string { return proto1.CompactTextString(m) }
func (*Conf) ProtoMessage()    {}

type ConfReply struct {
	Cur   *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Abort bool       `protobuf:"varint,2,opt,name=Abort" json:"Abort,omitempty"`
}

func (m *ConfReply) Reset()         { *m = ConfReply{} }
func (m *ConfReply) String() string { return proto1.CompactTextString(m) }
func (*ConfReply) ProtoMessage()    {}

func (m *ConfReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type Node struct {
	Id      uint32 `protobuf:"varint,1,opt,name=Id" json:"Id,omitempty"`
	Version uint32 `protobuf:"varint,2,opt,name=Version" json:"Version,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto1.CompactTextString(m) }
func (*Node) ProtoMessage()    {}

type Blueprint struct {
	Nodes          []*Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	FaultTolerance uint32  `protobuf:"varint,3,opt,name=FaultTolerance" json:"FaultTolerance,omitempty"`
	Epoch          uint32  `protobuf:"varint,4,opt,name=Epoch" json:"Epoch,omitempty"`
}

func (m *Blueprint) Reset()         { *m = Blueprint{} }
func (m *Blueprint) String() string { return proto1.CompactTextString(m) }
func (*Blueprint) ProtoMessage()    {}

func (m *Blueprint) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type NewCur struct {
	Cur  *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	CurC uint32     `protobuf:"varint,2,opt,name=CurC" json:"CurC,omitempty"`
}

func (m *NewCur) Reset()         { *m = NewCur{} }
func (m *NewCur) String() string { return proto1.CompactTextString(m) }
func (*NewCur) ProtoMessage()    {}

func (m *NewCur) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type NewCurReply struct {
	New bool `protobuf:"varint,1,opt,name=New" json:"New,omitempty"`
}

func (m *NewCurReply) Reset()         { *m = NewCurReply{} }
func (m *NewCurReply) String() string { return proto1.CompactTextString(m) }
func (*NewCurReply) ProtoMessage()    {}

type Read struct {
	Conf *Conf `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *Read) Reset()         { *m = Read{} }
func (m *Read) String() string { return proto1.CompactTextString(m) }
func (*Read) ProtoMessage()    {}

func (m *Read) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type ReadReply struct {
	State *State       `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *ConfReply   `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *ReadReply) Reset()         { *m = ReadReply{} }
func (m *ReadReply) String() string { return proto1.CompactTextString(m) }
func (*ReadReply) ProtoMessage()    {}

func (m *ReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ReadReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *ReadReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteS struct {
	State *State `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Conf  *Conf  `protobuf:"bytes,2,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *WriteS) Reset()         { *m = WriteS{} }
func (m *WriteS) String() string { return proto1.CompactTextString(m) }
func (*WriteS) ProtoMessage()    {}

func (m *WriteS) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteS) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type WriteSReply struct {
	Cur  *ConfReply   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *WriteSReply) Reset()         { *m = WriteSReply{} }
func (m *WriteSReply) String() string { return proto1.CompactTextString(m) }
func (*WriteSReply) ProtoMessage()    {}

func (m *WriteSReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *WriteSReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type AdvRead struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
}

func (m *AdvRead) Reset()         { *m = AdvRead{} }
func (m *AdvRead) String() string { return proto1.CompactTextString(m) }
func (*AdvRead) ProtoMessage()    {}

type AdvReadReply struct {
	State *State       `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *Blueprint   `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *AdvReadReply) Reset()         { *m = AdvReadReply{} }
func (m *AdvReadReply) String() string { return proto1.CompactTextString(m) }
func (*AdvReadReply) ProtoMessage()    {}

func (m *AdvReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *AdvReadReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *AdvReadReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type AdvWriteS struct {
	State *State `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	CurC  uint32 `protobuf:"varint,2,opt,name=CurC" json:"CurC,omitempty"`
}

func (m *AdvWriteS) Reset()         { *m = AdvWriteS{} }
func (m *AdvWriteS) String() string { return proto1.CompactTextString(m) }
func (*AdvWriteS) ProtoMessage()    {}

func (m *AdvWriteS) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type AdvWriteSReply struct {
	Cur  *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *AdvWriteSReply) Reset()         { *m = AdvWriteSReply{} }
func (m *AdvWriteSReply) String() string { return proto1.CompactTextString(m) }
func (*AdvWriteSReply) ProtoMessage()    {}

func (m *AdvWriteSReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *AdvWriteSReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteN struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Next *Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *WriteN) Reset()         { *m = WriteN{} }
func (m *WriteN) String() string { return proto1.CompactTextString(m) }
func (*WriteN) ProtoMessage()    {}

func (m *WriteN) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteNReply struct {
	Cur     *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	State   *State       `protobuf:"bytes,2,opt,name=State" json:"State,omitempty"`
	Next    []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
	LAState *Blueprint   `protobuf:"bytes,4,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *WriteNReply) Reset()         { *m = WriteNReply{} }
func (m *WriteNReply) String() string { return proto1.CompactTextString(m) }
func (*WriteNReply) ProtoMessage()    {}

func (m *WriteNReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *WriteNReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteNReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *WriteNReply) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type LAProposal struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Prop *Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *LAProposal) Reset()         { *m = LAProposal{} }
func (m *LAProposal) String() string { return proto1.CompactTextString(m) }
func (*LAProposal) ProtoMessage()    {}

func (m *LAProposal) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type LAReply struct {
	Cur     *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	LAState *Blueprint   `protobuf:"bytes,2,opt,name=LAState" json:"LAState,omitempty"`
	Next    []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *LAReply) Reset()         { *m = LAReply{} }
func (m *LAReply) String() string { return proto1.CompactTextString(m) }
func (*LAReply) ProtoMessage()    {}

func (m *LAReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *LAReply) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

func (m *LAReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type NewState struct {
	CurC    uint32     `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Cur     *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	State   *State     `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
	LAState *Blueprint `protobuf:"bytes,4,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *NewState) Reset()         { *m = NewState{} }
func (m *NewState) String() string { return proto1.CompactTextString(m) }
func (*NewState) ProtoMessage()    {}

func (m *NewState) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewState) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NewState) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewStateReply struct {
	Cur  *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *NewStateReply) Reset()         { *m = NewStateReply{} }
func (m *NewStateReply) String() string { return proto1.CompactTextString(m) }
func (*NewStateReply) ProtoMessage()    {}

func (m *NewStateReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewStateReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type DRead struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Prop *Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *DRead) Reset()         { *m = DRead{} }
func (m *DRead) String() string { return proto1.CompactTextString(m) }
func (*DRead) ProtoMessage()    {}

func (m *DRead) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type DWriteN struct {
	CurC uint32       `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *DWriteN) Reset()         { *m = DWriteN{} }
func (m *DWriteN) String() string { return proto1.CompactTextString(m) }
func (*DWriteN) ProtoMessage()    {}

func (m *DWriteN) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type DWriteNReply struct {
	Cur *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *DWriteNReply) Reset()         { *m = DWriteNReply{} }
func (m *DWriteNReply) String() string { return proto1.CompactTextString(m) }
func (*DWriteNReply) ProtoMessage()    {}

func (m *DWriteNReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type GetOne struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Next *Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *GetOne) Reset()         { *m = GetOne{} }
func (m *GetOne) String() string { return proto1.CompactTextString(m) }
func (*GetOne) ProtoMessage()    {}

func (m *GetOne) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type GetOneReply struct {
	Next *Blueprint `protobuf:"bytes,1,opt,name=Next" json:"Next,omitempty"`
	Cur  *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *GetOneReply) Reset()         { *m = GetOneReply{} }
func (m *GetOneReply) String() string { return proto1.CompactTextString(m) }
func (*GetOneReply) ProtoMessage()    {}

func (m *GetOneReply) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *GetOneReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type CV struct {
	Rnd uint32     `protobuf:"varint,1,opt,name=Rnd" json:"Rnd,omitempty"`
	Val *Blueprint `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *CV) Reset()         { *m = CV{} }
func (m *CV) String() string { return proto1.CompactTextString(m) }
func (*CV) ProtoMessage()    {}

func (m *CV) GetVal() *Blueprint {
	if m != nil {
		return m.Val
	}
	return nil
}

type Prepare struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Rnd  uint32 `protobuf:"varint,2,opt,name=Rnd" json:"Rnd,omitempty"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto1.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}

type Promise struct {
	Cur *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Rnd uint32     `protobuf:"varint,2,opt,name=Rnd" json:"Rnd,omitempty"`
	Val *CV        `protobuf:"bytes,3,opt,name=Val" json:"Val,omitempty"`
	Dec *Blueprint `protobuf:"bytes,4,opt,name=Dec" json:"Dec,omitempty"`
}

func (m *Promise) Reset()         { *m = Promise{} }
func (m *Promise) String() string { return proto1.CompactTextString(m) }
func (*Promise) ProtoMessage()    {}

func (m *Promise) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Promise) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Promise) GetDec() *Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

type Propose struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC" json:"CurC,omitempty"`
	Val  *CV    `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *Propose) Reset()         { *m = Propose{} }
func (m *Propose) String() string { return proto1.CompactTextString(m) }
func (*Propose) ProtoMessage()    {}

func (m *Propose) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

type Learn struct {
	Cur     *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Dec     *Blueprint `protobuf:"bytes,2,opt,name=Dec" json:"Dec,omitempty"`
	Learned bool       `protobuf:"varint,3,opt,name=Learned" json:"Learned,omitempty"`
}

func (m *Learn) Reset()         { *m = Learn{} }
func (m *Learn) String() string { return proto1.CompactTextString(m) }
func (*Learn) ProtoMessage()    {}

func (m *Learn) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Learn) GetDec() *Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for AdvRegister service

type AdvRegisterClient interface {
	AReadS(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error)
	AWriteS(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*WriteSReply, error)
	AWriteN(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error)
	SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
	LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error)
	SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error)
	GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error)
	Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error)
}

type advRegisterClient struct {
	cc *grpc.ClientConn
}

func NewAdvRegisterClient(cc *grpc.ClientConn) AdvRegisterClient {
	return &advRegisterClient{cc}
}

func (c *advRegisterClient) AReadS(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error) {
	out := new(ReadReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AReadS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) AWriteS(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*WriteSReply, error) {
	out := new(WriteSReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AWriteS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) AWriteN(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error) {
	out := new(WriteNReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AWriteN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/SetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error) {
	out := new(LAReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/LAProp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error) {
	out := new(NewStateReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/SetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error) {
	out := new(Promise)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/GetPromise", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error) {
	out := new(Learn)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/Accept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdvRegister service

type AdvRegisterServer interface {
	AReadS(context.Context, *Conf) (*ReadReply, error)
	AWriteS(context.Context, *WriteS) (*WriteSReply, error)
	AWriteN(context.Context, *WriteN) (*WriteNReply, error)
	SetCur(context.Context, *NewCur) (*NewCurReply, error)
	LAProp(context.Context, *LAProposal) (*LAReply, error)
	SetState(context.Context, *NewState) (*NewStateReply, error)
	GetPromise(context.Context, *Prepare) (*Promise, error)
	Accept(context.Context, *Propose) (*Learn, error)
}

func RegisterAdvRegisterServer(s *grpc.Server, srv AdvRegisterServer) {
	s.RegisterService(&_AdvRegister_serviceDesc, srv)
}

func _AdvRegister_AReadS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Conf)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AReadS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_AWriteS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteS)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AWriteS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_AWriteN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AWriteN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_SetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).SetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_LAProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(LAProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).LAProp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewState)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).SetState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_GetPromise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Prepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).GetPromise(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Propose)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).Accept(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _AdvRegister_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AdvRegister",
	HandlerType: (*AdvRegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AReadS",
			Handler:    _AdvRegister_AReadS_Handler,
		},
		{
			MethodName: "AWriteS",
			Handler:    _AdvRegister_AWriteS_Handler,
		},
		{
			MethodName: "AWriteN",
			Handler:    _AdvRegister_AWriteN_Handler,
		},
		{
			MethodName: "SetCur",
			Handler:    _AdvRegister_SetCur_Handler,
		},
		{
			MethodName: "LAProp",
			Handler:    _AdvRegister_LAProp_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _AdvRegister_SetState_Handler,
		},
		{
			MethodName: "GetPromise",
			Handler:    _AdvRegister_GetPromise_Handler,
		},
		{
			MethodName: "Accept",
			Handler:    _AdvRegister_Accept_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for DynaDisk service

type DynaDiskClient interface {
	DReadS(ctx context.Context, in *DRead, opts ...grpc.CallOption) (*AdvReadReply, error)
	DWriteS(ctx context.Context, in *AdvWriteS, opts ...grpc.CallOption) (*AdvWriteSReply, error)
	DWriteNSet(ctx context.Context, in *DWriteN, opts ...grpc.CallOption) (*DWriteNReply, error)
	GetOneN(ctx context.Context, in *GetOne, opts ...grpc.CallOption) (*GetOneReply, error)
	DSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
}

type dynaDiskClient struct {
	cc *grpc.ClientConn
}

func NewDynaDiskClient(cc *grpc.ClientConn) DynaDiskClient {
	return &dynaDiskClient{cc}
}

func (c *dynaDiskClient) DReadS(ctx context.Context, in *DRead, opts ...grpc.CallOption) (*AdvReadReply, error) {
	out := new(AdvReadReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DReadS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DWriteS(ctx context.Context, in *AdvWriteS, opts ...grpc.CallOption) (*AdvWriteSReply, error) {
	out := new(AdvWriteSReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DWriteS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DWriteNSet(ctx context.Context, in *DWriteN, opts ...grpc.CallOption) (*DWriteNReply, error) {
	out := new(DWriteNReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DWriteNSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) GetOneN(ctx context.Context, in *GetOne, opts ...grpc.CallOption) (*GetOneReply, error) {
	out := new(GetOneReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/GetOneN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DSetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DynaDisk service

type DynaDiskServer interface {
	DReadS(context.Context, *DRead) (*AdvReadReply, error)
	DWriteS(context.Context, *AdvWriteS) (*AdvWriteSReply, error)
	DWriteNSet(context.Context, *DWriteN) (*DWriteNReply, error)
	GetOneN(context.Context, *GetOne) (*GetOneReply, error)
	DSetCur(context.Context, *NewCur) (*NewCurReply, error)
}

func RegisterDynaDiskServer(s *grpc.Server, srv DynaDiskServer) {
	s.RegisterService(&_DynaDisk_serviceDesc, srv)
}

func _DynaDisk_DReadS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DRead)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DReadS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DWriteS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AdvWriteS)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DWriteS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DWriteNSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DWriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DWriteNSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_GetOneN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetOne)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).GetOneN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DSetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DSetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _DynaDisk_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DynaDisk",
	HandlerType: (*DynaDiskServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DReadS",
			Handler:    _DynaDisk_DReadS_Handler,
		},
		{
			MethodName: "DWriteS",
			Handler:    _DynaDisk_DWriteS_Handler,
		},
		{
			MethodName: "DWriteNSet",
			Handler:    _DynaDisk_DWriteNSet_Handler,
		},
		{
			MethodName: "GetOneN",
			Handler:    _DynaDisk_GetOneN_Handler,
		},
		{
			MethodName: "DSetCur",
			Handler:    _DynaDisk_DSetCur_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

/* Manager quorum functions specific */

// Manager manages a pool of machine configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	mu       sync.RWMutex
	ids      []uint32
	machines map[uint32]*Machine
	configs  map[uint32]*Configuration

	opts managerOptions

	aReadSqf     AReadSQuorumFn
	aWriteSqf    AWriteSQuorumFn
	aWriteNqf    AWriteNQuorumFn
	setCurqf     SetCurQuorumFn
	lAPropqf     LAPropQuorumFn
	setStateqf   SetStateQuorumFn
	getPromiseqf GetPromiseQuorumFn
	acceptqf     AcceptQuorumFn
	dReadSqf     DReadSQuorumFn
	dWriteSqf    DWriteSQuorumFn
	dWriteNSetqf DWriteNSetQuorumFn
	getOneNqf    GetOneNQuorumFn
	dSetCurqf    DSetCurQuorumFn
}

func (m *Manager) setDefaultQuorumFuncs() {
	if m.opts.aReadSqf != nil {
		m.aReadSqf = m.opts.aReadSqf
	} else {
		m.aReadSqf = func(c *Configuration, replies []*ReadReply) (*ReadReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.aWriteSqf != nil {
		m.aWriteSqf = m.opts.aWriteSqf
	} else {
		m.aWriteSqf = func(c *Configuration, replies []*WriteSReply) (*WriteSReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.aWriteNqf != nil {
		m.aWriteNqf = m.opts.aWriteNqf
	} else {
		m.aWriteNqf = func(c *Configuration, replies []*WriteNReply) (*WriteNReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.setCurqf != nil {
		m.setCurqf = m.opts.setCurqf
	} else {
		m.setCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.lAPropqf != nil {
		m.lAPropqf = m.opts.lAPropqf
	} else {
		m.lAPropqf = func(c *Configuration, replies []*LAReply) (*LAReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.setStateqf != nil {
		m.setStateqf = m.opts.setStateqf
	} else {
		m.setStateqf = func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.getPromiseqf != nil {
		m.getPromiseqf = m.opts.getPromiseqf
	} else {
		m.getPromiseqf = func(c *Configuration, replies []*Promise) (*Promise, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.acceptqf != nil {
		m.acceptqf = m.opts.acceptqf
	} else {
		m.acceptqf = func(c *Configuration, replies []*Learn) (*Learn, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dReadSqf != nil {
		m.dReadSqf = m.opts.dReadSqf
	} else {
		m.dReadSqf = func(c *Configuration, replies []*AdvReadReply) (*AdvReadReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dWriteSqf != nil {
		m.dWriteSqf = m.opts.dWriteSqf
	} else {
		m.dWriteSqf = func(c *Configuration, replies []*AdvWriteSReply) (*AdvWriteSReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dWriteNSetqf != nil {
		m.dWriteNSetqf = m.opts.dWriteNSetqf
	} else {
		m.dWriteNSetqf = func(c *Configuration, replies []*DWriteNReply) (*DWriteNReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.getOneNqf != nil {
		m.getOneNqf = m.opts.getOneNqf
	} else {
		m.getOneNqf = func(c *Configuration, replies []*GetOneReply) (*GetOneReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dSetCurqf != nil {
		m.dSetCurqf = m.opts.dSetCurqf
	} else {
		m.dSetCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
}

type managerOptions struct {
	grpcDialOpts []grpc.DialOption

	aReadSqf     AReadSQuorumFn
	aWriteSqf    AWriteSQuorumFn
	aWriteNqf    AWriteNQuorumFn
	setCurqf     SetCurQuorumFn
	lAPropqf     LAPropQuorumFn
	setStateqf   SetStateQuorumFn
	getPromiseqf GetPromiseQuorumFn
	acceptqf     AcceptQuorumFn
	dReadSqf     DReadSQuorumFn
	dWriteSqf    DWriteSQuorumFn
	dWriteNSetqf DWriteNSetQuorumFn
	getOneNqf    GetOneNQuorumFn
	dSetCurqf    DSetCurQuorumFn
}

// WithAReadSQuorumFunc returns a ManagerOption that sets a cumstom
// AReadSQuorumFunc.
func WithAReadSQuorumFunc(f AReadSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aReadSqf = f
	}
}

// WithAWriteSQuorumFunc returns a ManagerOption that sets a cumstom
// AWriteSQuorumFunc.
func WithAWriteSQuorumFunc(f AWriteSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aWriteSqf = f
	}
}

// WithAWriteNQuorumFunc returns a ManagerOption that sets a cumstom
// AWriteNQuorumFunc.
func WithAWriteNQuorumFunc(f AWriteNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aWriteNqf = f
	}
}

// WithSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// SetCurQuorumFunc.
func WithSetCurQuorumFunc(f SetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.setCurqf = f
	}
}

// WithLAPropQuorumFunc returns a ManagerOption that sets a cumstom
// LAPropQuorumFunc.
func WithLAPropQuorumFunc(f LAPropQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.lAPropqf = f
	}
}

// WithSetStateQuorumFunc returns a ManagerOption that sets a cumstom
// SetStateQuorumFunc.
func WithSetStateQuorumFunc(f SetStateQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.setStateqf = f
	}
}

// WithGetPromiseQuorumFunc returns a ManagerOption that sets a cumstom
// GetPromiseQuorumFunc.
func WithGetPromiseQuorumFunc(f GetPromiseQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.getPromiseqf = f
	}
}

// WithAcceptQuorumFunc returns a ManagerOption that sets a cumstom
// AcceptQuorumFunc.
func WithAcceptQuorumFunc(f AcceptQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.acceptqf = f
	}
}

// WithDReadSQuorumFunc returns a ManagerOption that sets a cumstom
// DReadSQuorumFunc.
func WithDReadSQuorumFunc(f DReadSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dReadSqf = f
	}
}

// WithDWriteSQuorumFunc returns a ManagerOption that sets a cumstom
// DWriteSQuorumFunc.
func WithDWriteSQuorumFunc(f DWriteSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dWriteSqf = f
	}
}

// WithDWriteNSetQuorumFunc returns a ManagerOption that sets a cumstom
// DWriteNSetQuorumFunc.
func WithDWriteNSetQuorumFunc(f DWriteNSetQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dWriteNSetqf = f
	}
}

// WithGetOneNQuorumFunc returns a ManagerOption that sets a cumstom
// GetOneNQuorumFunc.
func WithGetOneNQuorumFunc(f GetOneNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.getOneNqf = f
	}
}

// WithDSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// DSetCurQuorumFunc.
func WithDSetCurQuorumFunc(f DSetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dSetCurqf = f
	}
}

// AReadSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AReadSQuorumFn func(c *Configuration, replies []*ReadReply) (*ReadReply, bool)

// AWriteSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AWriteSQuorumFn func(c *Configuration, replies []*WriteSReply) (*WriteSReply, bool)

// AWriteNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AWriteNQuorumFn func(c *Configuration, replies []*WriteNReply) (*WriteNReply, bool)

// SetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

// LAPropQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type LAPropQuorumFn func(c *Configuration, replies []*LAReply) (*LAReply, bool)

// SetStateQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SetStateQuorumFn func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool)

// GetPromiseQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type GetPromiseQuorumFn func(c *Configuration, replies []*Promise) (*Promise, bool)

// AcceptQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AcceptQuorumFn func(c *Configuration, replies []*Learn) (*Learn, bool)

// DReadSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DReadSQuorumFn func(c *Configuration, replies []*AdvReadReply) (*AdvReadReply, bool)

// DWriteSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DWriteSQuorumFn func(c *Configuration, replies []*AdvWriteSReply) (*AdvWriteSReply, bool)

// DWriteNSetQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DWriteNSetQuorumFn func(c *Configuration, replies []*DWriteNReply) (*DWriteNReply, bool)

// GetOneNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type GetOneNQuorumFn func(c *Configuration, replies []*GetOneReply) (*GetOneReply, bool)

// DSetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DSetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

/* Gorums Client API */

/* Configuration RPC specific */

// AReadSReply encapsulates the reply from a AReadS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AReadSReply struct {
	MachineIDs []uint32
	Reply      *ReadReply
}

func (r AReadSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AReadSReply invokes a AReadS RPC on configuration c
// and returns the result as a AReadSReply.
func (c *Configuration) AReadS(args *Conf) (*AReadSReply, error) {
	return c.mgr.aReadS(c.id, args)
}

// AReadSFuture is a reference to an asynchronous AReadS RPC invocation.
type AReadSFuture struct {
	reply *AReadSReply
	err   error
	c     chan struct{}
}

// AReadSFuture asynchronously invokes a AReadS RPC on configuration c and
// returns a AReadSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AReadSFuture(args *Conf) *AReadSFuture {
	f := new(AReadSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aReadS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AReadSFuture.
// The method blocks until a reply or error is available.
func (f *AReadSFuture) Get() (*AReadSReply, error) {
	<-f.c
	return f.reply, f.err
}

// AWriteSReply encapsulates the reply from a AWriteS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AWriteSReply struct {
	MachineIDs []uint32
	Reply      *WriteSReply
}

func (r AWriteSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AWriteSReply invokes a AWriteS RPC on configuration c
// and returns the result as a AWriteSReply.
func (c *Configuration) AWriteS(args *WriteS) (*AWriteSReply, error) {
	return c.mgr.aWriteS(c.id, args)
}

// AWriteSFuture is a reference to an asynchronous AWriteS RPC invocation.
type AWriteSFuture struct {
	reply *AWriteSReply
	err   error
	c     chan struct{}
}

// AWriteSFuture asynchronously invokes a AWriteS RPC on configuration c and
// returns a AWriteSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AWriteSFuture(args *WriteS) *AWriteSFuture {
	f := new(AWriteSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aWriteS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AWriteSFuture.
// The method blocks until a reply or error is available.
func (f *AWriteSFuture) Get() (*AWriteSReply, error) {
	<-f.c
	return f.reply, f.err
}

// AWriteNReply encapsulates the reply from a AWriteN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AWriteNReply struct {
	MachineIDs []uint32
	Reply      *WriteNReply
}

func (r AWriteNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AWriteNReply invokes a AWriteN RPC on configuration c
// and returns the result as a AWriteNReply.
func (c *Configuration) AWriteN(args *WriteN) (*AWriteNReply, error) {
	return c.mgr.aWriteN(c.id, args)
}

// AWriteNFuture is a reference to an asynchronous AWriteN RPC invocation.
type AWriteNFuture struct {
	reply *AWriteNReply
	err   error
	c     chan struct{}
}

// AWriteNFuture asynchronously invokes a AWriteN RPC on configuration c and
// returns a AWriteNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AWriteNFuture(args *WriteN) *AWriteNFuture {
	f := new(AWriteNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aWriteN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AWriteNFuture.
// The method blocks until a reply or error is available.
func (f *AWriteNFuture) Get() (*AWriteNReply, error) {
	<-f.c
	return f.reply, f.err
}

// SetCurReply encapsulates the reply from a SetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SetCurReply struct {
	MachineIDs []uint32
	Reply      *NewCurReply
}

func (r SetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SetCurReply invokes a SetCur RPC on configuration c
// and returns the result as a SetCurReply.
func (c *Configuration) SetCur(args *NewCur) (*SetCurReply, error) {
	return c.mgr.setCur(c.id, args)
}

// SetCurFuture is a reference to an asynchronous SetCur RPC invocation.
type SetCurFuture struct {
	reply *SetCurReply
	err   error
	c     chan struct{}
}

// SetCurFuture asynchronously invokes a SetCur RPC on configuration c and
// returns a SetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SetCurFuture(args *NewCur) *SetCurFuture {
	f := new(SetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.setCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SetCurFuture.
// The method blocks until a reply or error is available.
func (f *SetCurFuture) Get() (*SetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

// LAPropReply encapsulates the reply from a LAProp RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type LAPropReply struct {
	MachineIDs []uint32
	Reply      *LAReply
}

func (r LAPropReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// LAPropReply invokes a LAProp RPC on configuration c
// and returns the result as a LAPropReply.
func (c *Configuration) LAProp(args *LAProposal) (*LAPropReply, error) {
	return c.mgr.lAProp(c.id, args)
}

// LAPropFuture is a reference to an asynchronous LAProp RPC invocation.
type LAPropFuture struct {
	reply *LAPropReply
	err   error
	c     chan struct{}
}

// LAPropFuture asynchronously invokes a LAProp RPC on configuration c and
// returns a LAPropFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) LAPropFuture(args *LAProposal) *LAPropFuture {
	f := new(LAPropFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.lAProp(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the LAPropFuture.
// The method blocks until a reply or error is available.
func (f *LAPropFuture) Get() (*LAPropReply, error) {
	<-f.c
	return f.reply, f.err
}

// SetStateReply encapsulates the reply from a SetState RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SetStateReply struct {
	MachineIDs []uint32
	Reply      *NewStateReply
}

func (r SetStateReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SetStateReply invokes a SetState RPC on configuration c
// and returns the result as a SetStateReply.
func (c *Configuration) SetState(args *NewState) (*SetStateReply, error) {
	return c.mgr.setState(c.id, args)
}

// SetStateFuture is a reference to an asynchronous SetState RPC invocation.
type SetStateFuture struct {
	reply *SetStateReply
	err   error
	c     chan struct{}
}

// SetStateFuture asynchronously invokes a SetState RPC on configuration c and
// returns a SetStateFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SetStateFuture(args *NewState) *SetStateFuture {
	f := new(SetStateFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.setState(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SetStateFuture.
// The method blocks until a reply or error is available.
func (f *SetStateFuture) Get() (*SetStateReply, error) {
	<-f.c
	return f.reply, f.err
}

// GetPromiseReply encapsulates the reply from a GetPromise RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type GetPromiseReply struct {
	MachineIDs []uint32
	Reply      *Promise
}

func (r GetPromiseReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// GetPromiseReply invokes a GetPromise RPC on configuration c
// and returns the result as a GetPromiseReply.
func (c *Configuration) GetPromise(args *Prepare) (*GetPromiseReply, error) {
	return c.mgr.getPromise(c.id, args)
}

// GetPromiseFuture is a reference to an asynchronous GetPromise RPC invocation.
type GetPromiseFuture struct {
	reply *GetPromiseReply
	err   error
	c     chan struct{}
}

// GetPromiseFuture asynchronously invokes a GetPromise RPC on configuration c and
// returns a GetPromiseFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) GetPromiseFuture(args *Prepare) *GetPromiseFuture {
	f := new(GetPromiseFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.getPromise(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the GetPromiseFuture.
// The method blocks until a reply or error is available.
func (f *GetPromiseFuture) Get() (*GetPromiseReply, error) {
	<-f.c
	return f.reply, f.err
}

// AcceptReply encapsulates the reply from a Accept RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AcceptReply struct {
	MachineIDs []uint32
	Reply      *Learn
}

func (r AcceptReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AcceptReply invokes a Accept RPC on configuration c
// and returns the result as a AcceptReply.
func (c *Configuration) Accept(args *Propose) (*AcceptReply, error) {
	return c.mgr.accept(c.id, args)
}

// AcceptFuture is a reference to an asynchronous Accept RPC invocation.
type AcceptFuture struct {
	reply *AcceptReply
	err   error
	c     chan struct{}
}

// AcceptFuture asynchronously invokes a Accept RPC on configuration c and
// returns a AcceptFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AcceptFuture(args *Propose) *AcceptFuture {
	f := new(AcceptFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.accept(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AcceptFuture.
// The method blocks until a reply or error is available.
func (f *AcceptFuture) Get() (*AcceptReply, error) {
	<-f.c
	return f.reply, f.err
}

// DReadSReply encapsulates the reply from a DReadS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DReadSReply struct {
	MachineIDs []uint32
	Reply      *AdvReadReply
}

func (r DReadSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DReadSReply invokes a DReadS RPC on configuration c
// and returns the result as a DReadSReply.
func (c *Configuration) DReadS(args *DRead) (*DReadSReply, error) {
	return c.mgr.dReadS(c.id, args)
}

// DReadSFuture is a reference to an asynchronous DReadS RPC invocation.
type DReadSFuture struct {
	reply *DReadSReply
	err   error
	c     chan struct{}
}

// DReadSFuture asynchronously invokes a DReadS RPC on configuration c and
// returns a DReadSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DReadSFuture(args *DRead) *DReadSFuture {
	f := new(DReadSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dReadS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DReadSFuture.
// The method blocks until a reply or error is available.
func (f *DReadSFuture) Get() (*DReadSReply, error) {
	<-f.c
	return f.reply, f.err
}

// DWriteSReply encapsulates the reply from a DWriteS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DWriteSReply struct {
	MachineIDs []uint32
	Reply      *AdvWriteSReply
}

func (r DWriteSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DWriteSReply invokes a DWriteS RPC on configuration c
// and returns the result as a DWriteSReply.
func (c *Configuration) DWriteS(args *AdvWriteS) (*DWriteSReply, error) {
	return c.mgr.dWriteS(c.id, args)
}

// DWriteSFuture is a reference to an asynchronous DWriteS RPC invocation.
type DWriteSFuture struct {
	reply *DWriteSReply
	err   error
	c     chan struct{}
}

// DWriteSFuture asynchronously invokes a DWriteS RPC on configuration c and
// returns a DWriteSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DWriteSFuture(args *AdvWriteS) *DWriteSFuture {
	f := new(DWriteSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dWriteS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DWriteSFuture.
// The method blocks until a reply or error is available.
func (f *DWriteSFuture) Get() (*DWriteSReply, error) {
	<-f.c
	return f.reply, f.err
}

// DWriteNSetReply encapsulates the reply from a DWriteNSet RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DWriteNSetReply struct {
	MachineIDs []uint32
	Reply      *DWriteNReply
}

func (r DWriteNSetReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DWriteNSetReply invokes a DWriteNSet RPC on configuration c
// and returns the result as a DWriteNSetReply.
func (c *Configuration) DWriteNSet(args *DWriteN) (*DWriteNSetReply, error) {
	return c.mgr.dWriteNSet(c.id, args)
}

// DWriteNSetFuture is a reference to an asynchronous DWriteNSet RPC invocation.
type DWriteNSetFuture struct {
	reply *DWriteNSetReply
	err   error
	c     chan struct{}
}

// DWriteNSetFuture asynchronously invokes a DWriteNSet RPC on configuration c and
// returns a DWriteNSetFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DWriteNSetFuture(args *DWriteN) *DWriteNSetFuture {
	f := new(DWriteNSetFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dWriteNSet(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DWriteNSetFuture.
// The method blocks until a reply or error is available.
func (f *DWriteNSetFuture) Get() (*DWriteNSetReply, error) {
	<-f.c
	return f.reply, f.err
}

// GetOneNReply encapsulates the reply from a GetOneN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type GetOneNReply struct {
	MachineIDs []uint32
	Reply      *GetOneReply
}

func (r GetOneNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// GetOneNReply invokes a GetOneN RPC on configuration c
// and returns the result as a GetOneNReply.
func (c *Configuration) GetOneN(args *GetOne) (*GetOneNReply, error) {
	return c.mgr.getOneN(c.id, args)
}

// GetOneNFuture is a reference to an asynchronous GetOneN RPC invocation.
type GetOneNFuture struct {
	reply *GetOneNReply
	err   error
	c     chan struct{}
}

// GetOneNFuture asynchronously invokes a GetOneN RPC on configuration c and
// returns a GetOneNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) GetOneNFuture(args *GetOne) *GetOneNFuture {
	f := new(GetOneNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.getOneN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the GetOneNFuture.
// The method blocks until a reply or error is available.
func (f *GetOneNFuture) Get() (*GetOneNReply, error) {
	<-f.c
	return f.reply, f.err
}

// DSetCurReply encapsulates the reply from a DSetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DSetCurReply struct {
	MachineIDs []uint32
	Reply      *NewCurReply
}

func (r DSetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DSetCurReply invokes a DSetCur RPC on configuration c
// and returns the result as a DSetCurReply.
func (c *Configuration) DSetCur(args *NewCur) (*DSetCurReply, error) {
	return c.mgr.dSetCur(c.id, args)
}

// DSetCurFuture is a reference to an asynchronous DSetCur RPC invocation.
type DSetCurFuture struct {
	reply *DSetCurReply
	err   error
	c     chan struct{}
}

// DSetCurFuture asynchronously invokes a DSetCur RPC on configuration c and
// returns a DSetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DSetCurFuture(args *NewCur) *DSetCurFuture {
	f := new(DSetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dSetCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DSetCurFuture.
// The method blocks until a reply or error is available.
func (f *DSetCurFuture) Get() (*DSetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

/* Manager RPC specific */

type aReadSReply struct {
	mid   uint32
	reply *ReadReply
	err   error
}

func (m *Manager) aReadS(configID uint32, args *Conf) (*AReadSReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan aReadSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*ReadReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(ReadReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/AReadS",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aReadSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &AReadSReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.aReadSqf(c, replyValues); ok {
				return &AReadSReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.aReadSqf(c, replyValues)
			return &AReadSReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type aWriteSReply struct {
	mid   uint32
	reply *WriteSReply
	err   error
}

func (m *Manager) aWriteS(configID uint32, args *WriteS) (*AWriteSReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan aWriteSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*WriteSReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(WriteSReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/AWriteS",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aWriteSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &AWriteSReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.aWriteSqf(c, replyValues); ok {
				return &AWriteSReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.aWriteSqf(c, replyValues)
			return &AWriteSReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type aWriteNReply struct {
	mid   uint32
	reply *WriteNReply
	err   error
}

func (m *Manager) aWriteN(configID uint32, args *WriteN) (*AWriteNReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan aWriteNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*WriteNReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(WriteNReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/AWriteN",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aWriteNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &AWriteNReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.aWriteNqf(c, replyValues); ok {
				return &AWriteNReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.aWriteNqf(c, replyValues)
			return &AWriteNReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type setCurReply struct {
	mid   uint32
	reply *NewCurReply
	err   error
}

func (m *Manager) setCur(configID uint32, args *NewCur) (*SetCurReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan setCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/SetCur",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- setCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &SetCurReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.setCurqf(c, replyValues); ok {
				return &SetCurReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.setCurqf(c, replyValues)
			return &SetCurReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type lAPropReply struct {
	mid   uint32
	reply *LAReply
	err   error
}

func (m *Manager) lAProp(configID uint32, args *LAProposal) (*LAPropReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan lAPropReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*LAReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(LAReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/LAProp",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- lAPropReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &LAPropReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.lAPropqf(c, replyValues); ok {
				return &LAPropReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.lAPropqf(c, replyValues)
			return &LAPropReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type setStateReply struct {
	mid   uint32
	reply *NewStateReply
	err   error
}

func (m *Manager) setState(configID uint32, args *NewState) (*SetStateReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan setStateReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewStateReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(NewStateReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/SetState",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- setStateReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &SetStateReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.setStateqf(c, replyValues); ok {
				return &SetStateReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.setStateqf(c, replyValues)
			return &SetStateReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type getPromiseReply struct {
	mid   uint32
	reply *Promise
	err   error
}

func (m *Manager) getPromise(configID uint32, args *Prepare) (*GetPromiseReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan getPromiseReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Promise, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(Promise)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/GetPromise",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- getPromiseReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &GetPromiseReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.getPromiseqf(c, replyValues); ok {
				return &GetPromiseReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.getPromiseqf(c, replyValues)
			return &GetPromiseReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type acceptReply struct {
	mid   uint32
	reply *Learn
	err   error
}

func (m *Manager) accept(configID uint32, args *Propose) (*AcceptReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan acceptReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Learn, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(Learn)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.AdvRegister/Accept",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- acceptReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &AcceptReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.acceptqf(c, replyValues); ok {
				return &AcceptReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.acceptqf(c, replyValues)
			return &AcceptReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dReadSReply struct {
	mid   uint32
	reply *AdvReadReply
	err   error
}

func (m *Manager) dReadS(configID uint32, args *DRead) (*DReadSReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan dReadSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*AdvReadReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(AdvReadReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.DynaDisk/DReadS",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dReadSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &DReadSReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.dReadSqf(c, replyValues); ok {
				return &DReadSReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.dReadSqf(c, replyValues)
			return &DReadSReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dWriteSReply struct {
	mid   uint32
	reply *AdvWriteSReply
	err   error
}

func (m *Manager) dWriteS(configID uint32, args *AdvWriteS) (*DWriteSReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan dWriteSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*AdvWriteSReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(AdvWriteSReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.DynaDisk/DWriteS",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dWriteSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &DWriteSReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.dWriteSqf(c, replyValues); ok {
				return &DWriteSReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.dWriteSqf(c, replyValues)
			return &DWriteSReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dWriteNSetReply struct {
	mid   uint32
	reply *DWriteNReply
	err   error
}

func (m *Manager) dWriteNSet(configID uint32, args *DWriteN) (*DWriteNSetReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan dWriteNSetReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*DWriteNReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(DWriteNReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.DynaDisk/DWriteNSet",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dWriteNSetReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &DWriteNSetReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.dWriteNSetqf(c, replyValues); ok {
				return &DWriteNSetReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.dWriteNSetqf(c, replyValues)
			return &DWriteNSetReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type getOneNReply struct {
	mid   uint32
	reply *GetOneReply
	err   error
}

func (m *Manager) getOneN(configID uint32, args *GetOne) (*GetOneNReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan getOneNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*GetOneReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(GetOneReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.DynaDisk/GetOneN",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- getOneNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &GetOneNReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.getOneNqf(c, replyValues); ok {
				return &GetOneNReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.getOneNqf(c, replyValues)
			return &GetOneNReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dSetCurReply struct {
	mid   uint32
	reply *NewCurReply
	err   error
}

func (m *Manager) dSetCur(configID uint32, args *NewCur) (*DSetCurReply, error) {
	c, err := m.getConfig(configID)
	if err != nil {
		return nil, err
	}

	var (
		replyChan   = make(chan dSetCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		mids        = make([]uint32, 0, c.quorum)
		ctx         = context.Background()
		errCount    int
	)

	for _, mid := range c.machines {
		machine, err := m.getMachine(mid)
		if err != nil {
			return nil, err
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				ce <- grpc.Invoke(
					ctx,
					"/proto.DynaDisk/DSetCur",
					args,
					reply,
					machine.conn,
				)
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dSetCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer func() {
		close(stopSignal)
		//cancel()
	}()

	for {
	select_:
		select {
		case r := <-replyChan:
			if r.err != nil {
				if grpc.Code(r.err) == codes.Aborted {
					return &DSetCurReply{
						MachineIDs: []uint32{r.mid},
						Reply:      r.reply,
					}, AbortRPCError(grpc.ErrorDesc(r.err))
				}
				errCount++
				if errCount > len(c.machines)-c.Quorum() {
					return nil, IncompleteRPCError{
						errCount, len(replyValues),
					}
				}
				break select_
			}

			replyValues = append(replyValues, r.reply)
			mids = append(mids, r.mid)
			if pickedReply, ok := m.dSetCurqf(c, replyValues); ok {
				return &DSetCurReply{
					mids,
					pickedReply,
				}, nil
			}
		case <-time.After(c.timeout):
			pickedReply, _ := m.dSetCurqf(c, replyValues)
			return &DSetCurReply{
				mids,
				pickedReply,
			}, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.Size() {
			return nil, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

/* config.go */

// A Configuration represents a static set of machines on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id       uint32
	machines []uint32
	mgr      *Manager
	quorum   int
	timeout  time.Duration
}

// ID reports the unique identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// Machines returns a slice containing the ids of all the machines in the
// configuration.
func (c *Configuration) Machines() []uint32 { return c.machines }

// Quorum returns the quourm size for the configuration.
func (c *Configuration) Quorum() int {
	return c.quorum
}

// Size returns the number of machines in the configuration.
func (c *Configuration) Size() int {
	return len(c.machines)
}

func (c *Configuration) String() string {
	return fmt.Sprintf("Configuration %d", c.id)
}

// Equal retuns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

/* errors.go */

// A MachineNotFoundError reports that a specified machine could not be found.
type MachineNotFoundError uint32

func (e MachineNotFoundError) Error() string {
	return fmt.Sprintf("machine not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, RepliesCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.RepliesCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited                 time.Duration
	ErrCount, RepliesCount int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An AbortRPCError reports that a single machine signaled to abort the quorum
// RPC call.
type AbortRPCError string

func (e AbortRPCError) Error() string {
	return "single rpc reply signaled abort: " + string(e)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// A ManagerCreationError reports that a Manager could not be created.
type ManagerCreationError string

func (e ManagerCreationError) Error() string {
	return "could not create manager: " + string(e)
}

/* lat.go */

type latencyTuple struct {
	machineID  uint32
	reqLatency time.Duration
}

type latencySlice []latencyTuple

func (p latencySlice) Len() int           { return len(p) }
func (p latencySlice) Less(i, j int) bool { return p[i].reqLatency < (p[j].reqLatency) }
func (p latencySlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

func (p latencySlice) Sort() { sort.Sort(p) }

func sortLatencies(lats map[uint32]latencyTuple) latencySlice {
	ls := make(latencySlice, len(lats))
	i := 0
	for _, lat := range lats {
		ls[i] = lat
		i++
	}
	ls.Sort()
	return ls
}

/* machine.go */

// Machine encapsulates the state of a machine on which a remote procedure call
// can be made.
type Machine struct {
	// Only assigned at creation.
	id   uint32
	addr string
	conn *grpc.ClientConn

	sync.Mutex
	lastErr error
	latency time.Duration
}

// ConnState returns the state of the underlying gRPC client connection.
func (m *Machine) ConnState() grpc.ConnectivityState {
	return m.conn.State()
}

func (m *Machine) String() string {
	m.Lock()
	defer m.Unlock()
	return fmt.Sprintf(
		"machine %d | addr: %s | latency: %v | connstate: %v",
		m.id,
		m.addr,
		m.latency,
		m.conn.State(),
	)
}

func (m *Machine) setLastErr(err error) {
	m.Lock()
	defer m.Unlock()
	m.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this machine.
func (m *Machine) LastErr() error {
	m.Lock()
	defer m.Unlock()
	return m.lastErr
}

func (m *Machine) setLatency(lat time.Duration) {
	m.Lock()
	defer m.Unlock()
	m.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this machine.
func (m *Machine) Latency() time.Duration {
	m.Lock()
	defer m.Unlock()
	return m.latency
}

// ByID attaches the methods of sort.Interface to []Machine, sorting machines
// by identifier in increasing order.
type ByID []Machine

func (p ByID) Len() int           { return len(p) }
func (p ByID) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
func (p ByID) Less(i, j int) bool { return p[i].id < p[j].id }

// ByLatency attaches the methods of sort.Interface to []Machine, sorting
// machines by latency in increasing order. Latencies less then zero (sentinel
// value) are considered greater than any positive latency.
type ByLatency []Machine

func (p ByLatency) Len() int      { return len(p) }
func (p ByLatency) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p ByLatency) Less(i, j int) bool {
	if p[i].latency < 0 {
		return false
	}
	return p[i].latency < p[j].latency
}

/* mgr.go */

// NewManager attempts to connect to the given machines, and returns a new
// Manager containing those machines if successful.
func NewManager(machines []string, opts ...ManagerOption) (*Manager, error) {
	if len(machines) == 0 {
		return nil, ManagerCreationError("no machines provided")
	}

	m := new(Manager)
	m.machines = make(map[uint32]*Machine)
	m.configs = make(map[uint32]*Configuration)

	for _, opt := range opts {
		opt(&m.opts)
	}

	m.setDefaultQuorumFuncs()

	for _, mn := range machines {
		err := m.createMachine(mn)
		if err != nil {
			return nil, ManagerCreationError(err.Error())
		}
	}

	return m, nil
}

// IDs returns the identifier of each available machine.
func (m *Manager) IDs() []uint32 {
	m.mu.RLock()
	defer m.mu.RUnlock()
	ids := make([]uint32, len(m.ids))
	copy(ids, m.ids)
	return ids
}

// Machine returns the machine with the given identifier if present.
func (m *Manager) Machine(id uint32) (machine *Machine, found bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	machine, found = m.machines[id]
	return machine, found
}

// Machines returns a slice of each available machine.
func (m *Manager) Machines() []*Machine {
	m.mu.RLock()
	defer m.mu.RUnlock()
	ma := make([]*Machine, len(m.ids))
	for i, id := range m.ids {
		ma[i] = m.machines[id]
	}
	return ma
}

// Size returns the number of machines in the Manager.
func (m *Manager) Size() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return len(m.ids)
}

func (m *Manager) createMachine(mn string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	h := fnv.New32a()
	h.Write([]byte(mn))
	id := h.Sum32()
	if _, machineExists := m.machines[id]; machineExists {
		return fmt.Errorf("create machine %s error: machine already exists", mn)
	}

	ma := &Machine{
		id:      id,
		addr:    mn,
		latency: -1 * time.Second,
	}

	err := m.connect(ma)
	if err != nil {
		return fmt.Errorf("create machine %s error: %v", mn, err)
	}

	m.ids = append(m.ids, id)
	m.machines[id] = ma

	return nil
}

func (m *Manager) connect(ma *Machine) error {
	conn, err := grpc.Dial(ma.addr, m.opts.grpcDialOpts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}
	ma.conn = conn
	return nil
}

type byID []uint32

func (a byID) Len() int           { return len(a) }
func (a byID) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a byID) Less(i, j int) bool { return a[i] < a[j] }

// NewConfiguration returns a new configuration given a set of machine ids and
// a quorum size. Any given gRPC call options will be used for every RPC
// invocation on the configuration.
func (m *Manager) NewConfiguration(ids []uint32, quorumSize int, timeout time.Duration) (*Configuration, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one machine")
	}
	if quorumSize > len(ids) || quorumSize < 1 {
		return nil, IllegalConfigError("invalid quourm size")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	// Machine ids are sorted to ensure a globally consistent configuration id.
	sort.Sort(byID(ids))

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, quorumSize)
	binary.Write(h, binary.LittleEndian, timeout)
	for _, id := range ids {
		_, found := m.machines[id]
		if !found {
			return nil, MachineNotFoundError(id)
		}
		binary.Write(h, binary.LittleEndian, id)
	}
	cid := h.Sum32()
	c, found := m.configs[cid]
	if found {
		return c, nil
	}
	c = &Configuration{
		id:       cid,
		machines: ids,
		mgr:      m,
		quorum:   quorumSize,
		timeout:  timeout,
	}
	m.configs[cid] = c

	return c, nil
}

// AddMachine attempts to dial to the provide machine address. The machine is
// added to the Manager's pool of machines if a connection was made.
func (m *Manager) AddMachine(addr string) error {
	return m.createMachine(addr)
}

func (m *Manager) getConfig(cid uint32) (*Configuration, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	c, found := m.configs[cid]
	if !found {
		return nil, ConfigNotFoundError(cid)
	}
	return c, nil
}

func (m *Manager) getMachine(mid uint32) (*Machine, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	ma, found := m.machines[mid]
	if !found {
		return nil, MachineNotFoundError(mid)
	}
	return ma, nil
}

/* opts.go */

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption that sets any gRPC dial options
// the Manager should use when initially connecting to each machine in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}
