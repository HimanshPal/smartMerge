// Code generated by protoc-gen-gogo.
// source: dc-smartMerge.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		dc-smartMerge.proto

	It has these top-level messages:
		State
		Conf
		ConfReply
		Node
		Blueprint
		NewCur
		NewCurReply
		Read
		ReadReply
		WriteS
		WriteN
		WriteNReply
		LAProposal
		LAReply
		NewState
		NewStateReply
		CV
		Prepare
		Promise
		Propose
		Learn
		Proposal
		Ack
		GetOne
		GetOneReply
		DRead
		DReadReply
		DNewState
		DWriteNs
		DWriteNsReply
		SWriteN
		SWriteNReply
		Commit
		CommitReply
		SState
		SStateReply
*/
package proto

import proto1 "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import bytes "bytes"

import (
	"encoding/binary"
	"hash/fnv"
	"log"
	"net"
	"sort"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type State struct {
	Value     []byte `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Timestamp int32  `protobuf:"varint,2,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Writer    uint32 `protobuf:"varint,3,opt,name=Writer,proto3" json:"Writer,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto1.CompactTextString(m) }
func (*State) ProtoMessage()    {}

type Conf struct {
	This uint32 `protobuf:"varint,1,opt,name=This,proto3" json:"This,omitempty"`
	Cur  uint32 `protobuf:"varint,2,opt,name=Cur,proto3" json:"Cur,omitempty"`
}

func (m *Conf) Reset()         { *m = Conf{} }
func (m *Conf) String() string { return proto1.CompactTextString(m) }
func (*Conf) ProtoMessage()    {}

type ConfReply struct {
	Cur   *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Abort bool         `protobuf:"varint,2,opt,name=Abort,proto3" json:"Abort,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *ConfReply) Reset()         { *m = ConfReply{} }
func (m *ConfReply) String() string { return proto1.CompactTextString(m) }
func (*ConfReply) ProtoMessage()    {}

func (m *ConfReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *ConfReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type Node struct {
	Id      uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Version uint32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto1.CompactTextString(m) }
func (*Node) ProtoMessage()    {}

type Blueprint struct {
	Nodes          []*Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	FaultTolerance uint32  `protobuf:"varint,3,opt,name=FaultTolerance,proto3" json:"FaultTolerance,omitempty"`
	Epoch          uint32  `protobuf:"varint,4,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
}

func (m *Blueprint) Reset()         { *m = Blueprint{} }
func (m *Blueprint) String() string { return proto1.CompactTextString(m) }
func (*Blueprint) ProtoMessage()    {}

func (m *Blueprint) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type NewCur struct {
	Cur  *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	CurC uint32     `protobuf:"varint,2,opt,name=CurC,proto3" json:"CurC,omitempty"`
}

func (m *NewCur) Reset()         { *m = NewCur{} }
func (m *NewCur) String() string { return proto1.CompactTextString(m) }
func (*NewCur) ProtoMessage()    {}

func (m *NewCur) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type NewCurReply struct {
	New bool `protobuf:"varint,1,opt,name=New,proto3" json:"New,omitempty"`
}

func (m *NewCurReply) Reset()         { *m = NewCurReply{} }
func (m *NewCurReply) String() string { return proto1.CompactTextString(m) }
func (*NewCurReply) ProtoMessage()    {}

type Read struct {
	Conf *Conf `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *Read) Reset()         { *m = Read{} }
func (m *Read) String() string { return proto1.CompactTextString(m) }
func (*Read) ProtoMessage()    {}

func (m *Read) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type ReadReply struct {
	State *State     `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *ConfReply `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *ReadReply) Reset()         { *m = ReadReply{} }
func (m *ReadReply) String() string { return proto1.CompactTextString(m) }
func (*ReadReply) ProtoMessage()    {}

func (m *ReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ReadReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

type WriteS struct {
	State *State `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Conf  *Conf  `protobuf:"bytes,2,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *WriteS) Reset()         { *m = WriteS{} }
func (m *WriteS) String() string { return proto1.CompactTextString(m) }
func (*WriteS) ProtoMessage()    {}

func (m *WriteS) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteS) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type WriteN struct {
	CurC uint32     `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Next *Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *WriteN) Reset()         { *m = WriteN{} }
func (m *WriteN) String() string { return proto1.CompactTextString(m) }
func (*WriteN) ProtoMessage()    {}

func (m *WriteN) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteNReply struct {
	Cur     *ConfReply `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	State   *State     `protobuf:"bytes,2,opt,name=State" json:"State,omitempty"`
	LAState *Blueprint `protobuf:"bytes,3,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *WriteNReply) Reset()         { *m = WriteNReply{} }
func (m *WriteNReply) String() string { return proto1.CompactTextString(m) }
func (*WriteNReply) ProtoMessage()    {}

func (m *WriteNReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *WriteNReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteNReply) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type LAProposal struct {
	Conf *Conf      `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Prop *Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *LAProposal) Reset()         { *m = LAProposal{} }
func (m *LAProposal) String() string { return proto1.CompactTextString(m) }
func (*LAProposal) ProtoMessage()    {}

func (m *LAProposal) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *LAProposal) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type LAReply struct {
	Cur     *ConfReply `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	LAState *Blueprint `protobuf:"bytes,2,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *LAReply) Reset()         { *m = LAReply{} }
func (m *LAReply) String() string { return proto1.CompactTextString(m) }
func (*LAReply) ProtoMessage()    {}

func (m *LAReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *LAReply) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewState struct {
	CurC    uint32     `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Cur     *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	State   *State     `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
	LAState *Blueprint `protobuf:"bytes,4,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *NewState) Reset()         { *m = NewState{} }
func (m *NewState) String() string { return proto1.CompactTextString(m) }
func (*NewState) ProtoMessage()    {}

func (m *NewState) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewState) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NewState) GetLAState() *Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewStateReply struct {
	Cur  *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *NewStateReply) Reset()         { *m = NewStateReply{} }
func (m *NewStateReply) String() string { return proto1.CompactTextString(m) }
func (*NewStateReply) ProtoMessage()    {}

func (m *NewStateReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewStateReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type CV struct {
	Rnd uint32     `protobuf:"varint,1,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Val *Blueprint `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *CV) Reset()         { *m = CV{} }
func (m *CV) String() string { return proto1.CompactTextString(m) }
func (*CV) ProtoMessage()    {}

func (m *CV) GetVal() *Blueprint {
	if m != nil {
		return m.Val
	}
	return nil
}

type Prepare struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Rnd  uint32 `protobuf:"varint,2,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto1.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}

type Promise struct {
	Cur *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Rnd uint32     `protobuf:"varint,2,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Val *CV        `protobuf:"bytes,3,opt,name=Val" json:"Val,omitempty"`
	Dec *Blueprint `protobuf:"bytes,4,opt,name=Dec" json:"Dec,omitempty"`
}

func (m *Promise) Reset()         { *m = Promise{} }
func (m *Promise) String() string { return proto1.CompactTextString(m) }
func (*Promise) ProtoMessage()    {}

func (m *Promise) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Promise) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Promise) GetDec() *Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

type Propose struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Val  *CV    `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *Propose) Reset()         { *m = Propose{} }
func (m *Propose) String() string { return proto1.CompactTextString(m) }
func (*Propose) ProtoMessage()    {}

func (m *Propose) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

type Learn struct {
	Cur     *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Dec     *Blueprint `protobuf:"bytes,2,opt,name=Dec" json:"Dec,omitempty"`
	Learned bool       `protobuf:"varint,3,opt,name=Learned,proto3" json:"Learned,omitempty"`
}

func (m *Learn) Reset()         { *m = Learn{} }
func (m *Learn) String() string { return proto1.CompactTextString(m) }
func (*Learn) ProtoMessage()    {}

func (m *Learn) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Learn) GetDec() *Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

type Proposal struct {
	Prop *Blueprint `protobuf:"bytes,1,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto1.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}

func (m *Proposal) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type Ack struct {
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto1.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}

type GetOne struct {
	Conf *Conf      `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Next *Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *GetOne) Reset()         { *m = GetOne{} }
func (m *GetOne) String() string { return proto1.CompactTextString(m) }
func (*GetOne) ProtoMessage()    {}

func (m *GetOne) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *GetOne) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type GetOneReply struct {
	Next *Blueprint `protobuf:"bytes,1,opt,name=Next" json:"Next,omitempty"`
	Cur  *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *GetOneReply) Reset()         { *m = GetOneReply{} }
func (m *GetOneReply) String() string { return proto1.CompactTextString(m) }
func (*GetOneReply) ProtoMessage()    {}

func (m *GetOneReply) GetNext() *Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *GetOneReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type DRead struct {
	Conf *Conf      `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Prop *Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *DRead) Reset()         { *m = DRead{} }
func (m *DRead) String() string { return proto1.CompactTextString(m) }
func (*DRead) ProtoMessage()    {}

func (m *DRead) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *DRead) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type DReadReply struct {
	State *State       `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *Blueprint   `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *DReadReply) Reset()         { *m = DReadReply{} }
func (m *DReadReply) String() string { return proto1.CompactTextString(m) }
func (*DReadReply) ProtoMessage()    {}

func (m *DReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DReadReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *DReadReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type DNewState struct {
	Conf  *Conf      `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Cur   *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	State *State     `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
}

func (m *DNewState) Reset()         { *m = DNewState{} }
func (m *DNewState) String() string { return proto1.CompactTextString(m) }
func (*DNewState) ProtoMessage()    {}

func (m *DNewState) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *DNewState) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *DNewState) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type DWriteNs struct {
	Conf *Conf        `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *DWriteNs) Reset()         { *m = DWriteNs{} }
func (m *DWriteNs) String() string { return proto1.CompactTextString(m) }
func (*DWriteNs) ProtoMessage()    {}

func (m *DWriteNs) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *DWriteNs) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type DWriteNsReply struct {
	Cur  *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *DWriteNsReply) Reset()         { *m = DWriteNsReply{} }
func (m *DWriteNsReply) String() string { return proto1.CompactTextString(m) }
func (*DWriteNsReply) ProtoMessage()    {}

func (m *DWriteNsReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *DWriteNsReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type SWriteN struct {
	CurL uint32     `protobuf:"varint,1,opt,name=CurL,proto3" json:"CurL,omitempty"`
	This uint32     `protobuf:"varint,2,opt,name=This,proto3" json:"This,omitempty"`
	Rnd  uint32     `protobuf:"varint,3,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Prop *Blueprint `protobuf:"bytes,4,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *SWriteN) Reset()         { *m = SWriteN{} }
func (m *SWriteN) String() string { return proto1.CompactTextString(m) }
func (*SWriteN) ProtoMessage()    {}

func (m *SWriteN) GetProp() *Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type SWriteNReply struct {
	Cur   *Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next  []*Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
	State *State       `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
}

func (m *SWriteNReply) Reset()         { *m = SWriteNReply{} }
func (m *SWriteNReply) String() string { return proto1.CompactTextString(m) }
func (*SWriteNReply) ProtoMessage()    {}

func (m *SWriteNReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *SWriteNReply) GetNext() []*Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *SWriteNReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type Commit struct {
	CurL    uint32     `protobuf:"varint,1,opt,name=CurL,proto3" json:"CurL,omitempty"`
	This    uint32     `protobuf:"varint,2,opt,name=This,proto3" json:"This,omitempty"`
	Rnd     uint32     `protobuf:"varint,3,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Commit  bool       `protobuf:"varint,4,opt,name=Commit,proto3" json:"Commit,omitempty"`
	Collect *Blueprint `protobuf:"bytes,5,opt,name=Collect" json:"Collect,omitempty"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto1.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}

func (m *Commit) GetCollect() *Blueprint {
	if m != nil {
		return m.Collect
	}
	return nil
}

type CommitReply struct {
	Cur       *Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Committed *Blueprint `protobuf:"bytes,2,opt,name=Committed" json:"Committed,omitempty"`
	Collected *Blueprint `protobuf:"bytes,3,opt,name=Collected" json:"Collected,omitempty"`
}

func (m *CommitReply) Reset()         { *m = CommitReply{} }
func (m *CommitReply) String() string { return proto1.CompactTextString(m) }
func (*CommitReply) ProtoMessage()    {}

func (m *CommitReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *CommitReply) GetCommitted() *Blueprint {
	if m != nil {
		return m.Committed
	}
	return nil
}

func (m *CommitReply) GetCollected() *Blueprint {
	if m != nil {
		return m.Collected
	}
	return nil
}

type SState struct {
	CurL  uint32     `protobuf:"varint,1,opt,name=CurL,proto3" json:"CurL,omitempty"`
	Cur   *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
	State *State     `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
}

func (m *SState) Reset()         { *m = SState{} }
func (m *SState) String() string { return proto1.CompactTextString(m) }
func (*SState) ProtoMessage()    {}

func (m *SState) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *SState) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type SStateReply struct {
	HasNext bool       `protobuf:"varint,1,opt,name=HasNext,proto3" json:"HasNext,omitempty"`
	Cur     *Blueprint `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *SStateReply) Reset()         { *m = SStateReply{} }
func (m *SStateReply) String() string { return proto1.CompactTextString(m) }
func (*SStateReply) ProtoMessage()    {}

func (m *SStateReply) GetCur() *Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func init() {
	proto1.RegisterType((*State)(nil), "proto.State")
	proto1.RegisterType((*Conf)(nil), "proto.Conf")
	proto1.RegisterType((*ConfReply)(nil), "proto.ConfReply")
	proto1.RegisterType((*Node)(nil), "proto.Node")
	proto1.RegisterType((*Blueprint)(nil), "proto.Blueprint")
	proto1.RegisterType((*NewCur)(nil), "proto.NewCur")
	proto1.RegisterType((*NewCurReply)(nil), "proto.NewCurReply")
	proto1.RegisterType((*Read)(nil), "proto.Read")
	proto1.RegisterType((*ReadReply)(nil), "proto.ReadReply")
	proto1.RegisterType((*WriteS)(nil), "proto.WriteS")
	proto1.RegisterType((*WriteN)(nil), "proto.WriteN")
	proto1.RegisterType((*WriteNReply)(nil), "proto.WriteNReply")
	proto1.RegisterType((*LAProposal)(nil), "proto.LAProposal")
	proto1.RegisterType((*LAReply)(nil), "proto.LAReply")
	proto1.RegisterType((*NewState)(nil), "proto.NewState")
	proto1.RegisterType((*NewStateReply)(nil), "proto.NewStateReply")
	proto1.RegisterType((*CV)(nil), "proto.CV")
	proto1.RegisterType((*Prepare)(nil), "proto.Prepare")
	proto1.RegisterType((*Promise)(nil), "proto.Promise")
	proto1.RegisterType((*Propose)(nil), "proto.Propose")
	proto1.RegisterType((*Learn)(nil), "proto.Learn")
	proto1.RegisterType((*Proposal)(nil), "proto.Proposal")
	proto1.RegisterType((*Ack)(nil), "proto.Ack")
	proto1.RegisterType((*GetOne)(nil), "proto.GetOne")
	proto1.RegisterType((*GetOneReply)(nil), "proto.GetOneReply")
	proto1.RegisterType((*DRead)(nil), "proto.DRead")
	proto1.RegisterType((*DReadReply)(nil), "proto.DReadReply")
	proto1.RegisterType((*DNewState)(nil), "proto.DNewState")
	proto1.RegisterType((*DWriteNs)(nil), "proto.DWriteNs")
	proto1.RegisterType((*DWriteNsReply)(nil), "proto.DWriteNsReply")
	proto1.RegisterType((*SWriteN)(nil), "proto.SWriteN")
	proto1.RegisterType((*SWriteNReply)(nil), "proto.SWriteNReply")
	proto1.RegisterType((*Commit)(nil), "proto.Commit")
	proto1.RegisterType((*CommitReply)(nil), "proto.CommitReply")
	proto1.RegisterType((*SState)(nil), "proto.SState")
	proto1.RegisterType((*SStateReply)(nil), "proto.SStateReply")
}
func (this *State) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*State)
	if !ok {
		return fmt.Errorf("that is not of type *State")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *State but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *State but is not nil && this == nil")
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Writer != that1.Writer {
		return fmt.Errorf("Writer this(%v) Not Equal that(%v)", this.Writer, that1.Writer)
	}
	return nil
}
func (this *State) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*State)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Writer != that1.Writer {
		return false
	}
	return true
}
func (this *Conf) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Conf)
	if !ok {
		return fmt.Errorf("that is not of type *Conf")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Conf but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Conf but is not nil && this == nil")
	}
	if this.This != that1.This {
		return fmt.Errorf("This this(%v) Not Equal that(%v)", this.This, that1.This)
	}
	if this.Cur != that1.Cur {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	return nil
}
func (this *Conf) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Conf)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.This != that1.This {
		return false
	}
	if this.Cur != that1.Cur {
		return false
	}
	return true
}
func (this *ConfReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ConfReply)
	if !ok {
		return fmt.Errorf("that is not of type *ConfReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ConfReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ConfReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if this.Abort != that1.Abort {
		return fmt.Errorf("Abort this(%v) Not Equal that(%v)", this.Abort, that1.Abort)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *ConfReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ConfReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if this.Abort != that1.Abort {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *Node) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Node)
	if !ok {
		return fmt.Errorf("that is not of type *Node")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Node but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Node but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	return nil
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Node)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *Blueprint) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Blueprint)
	if !ok {
		return fmt.Errorf("that is not of type *Blueprint")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Blueprint but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Blueprint but is not nil && this == nil")
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return fmt.Errorf("Nodes this(%v) Not Equal that(%v)", len(this.Nodes), len(that1.Nodes))
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return fmt.Errorf("Nodes this[%v](%v) Not Equal that[%v](%v)", i, this.Nodes[i], i, that1.Nodes[i])
		}
	}
	if this.FaultTolerance != that1.FaultTolerance {
		return fmt.Errorf("FaultTolerance this(%v) Not Equal that(%v)", this.FaultTolerance, that1.FaultTolerance)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	return nil
}
func (this *Blueprint) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Blueprint)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	if this.FaultTolerance != that1.FaultTolerance {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	return true
}
func (this *NewCur) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewCur)
	if !ok {
		return fmt.Errorf("that is not of type *NewCur")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewCur but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewCur but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	return nil
}
func (this *NewCur) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewCur)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	return true
}
func (this *NewCurReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewCurReply)
	if !ok {
		return fmt.Errorf("that is not of type *NewCurReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewCurReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewCurReply but is not nil && this == nil")
	}
	if this.New != that1.New {
		return fmt.Errorf("New this(%v) Not Equal that(%v)", this.New, that1.New)
	}
	return nil
}
func (this *NewCurReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewCurReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.New != that1.New {
		return false
	}
	return true
}
func (this *Read) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Read)
	if !ok {
		return fmt.Errorf("that is not of type *Read")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Read but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Read but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	return nil
}
func (this *Read) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Read)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	return true
}
func (this *ReadReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReadReply)
	if !ok {
		return fmt.Errorf("that is not of type *ReadReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReadReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReadReply but is not nil && this == nil")
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	return nil
}
func (this *ReadReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReadReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	return true
}
func (this *WriteS) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteS)
	if !ok {
		return fmt.Errorf("that is not of type *WriteS")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteS but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteS but is not nil && this == nil")
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	return nil
}
func (this *WriteS) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteS)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	return true
}
func (this *WriteN) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteN)
	if !ok {
		return fmt.Errorf("that is not of type *WriteN")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteN but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteN but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if !this.Next.Equal(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", this.Next, that1.Next)
	}
	return nil
}
func (this *WriteN) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteN)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if !this.Next.Equal(that1.Next) {
		return false
	}
	return true
}
func (this *WriteNReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteNReply)
	if !ok {
		return fmt.Errorf("that is not of type *WriteNReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteNReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteNReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.LAState.Equal(that1.LAState) {
		return fmt.Errorf("LAState this(%v) Not Equal that(%v)", this.LAState, that1.LAState)
	}
	return nil
}
func (this *WriteNReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteNReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.LAState.Equal(that1.LAState) {
		return false
	}
	return true
}
func (this *LAProposal) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LAProposal)
	if !ok {
		return fmt.Errorf("that is not of type *LAProposal")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LAProposal but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LAProposal but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	if !this.Prop.Equal(that1.Prop) {
		return fmt.Errorf("Prop this(%v) Not Equal that(%v)", this.Prop, that1.Prop)
	}
	return nil
}
func (this *LAProposal) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LAProposal)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	if !this.Prop.Equal(that1.Prop) {
		return false
	}
	return true
}
func (this *LAReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LAReply)
	if !ok {
		return fmt.Errorf("that is not of type *LAReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LAReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LAReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.LAState.Equal(that1.LAState) {
		return fmt.Errorf("LAState this(%v) Not Equal that(%v)", this.LAState, that1.LAState)
	}
	return nil
}
func (this *LAReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LAReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.LAState.Equal(that1.LAState) {
		return false
	}
	return true
}
func (this *NewState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewState)
	if !ok {
		return fmt.Errorf("that is not of type *NewState")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewState but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.LAState.Equal(that1.LAState) {
		return fmt.Errorf("LAState this(%v) Not Equal that(%v)", this.LAState, that1.LAState)
	}
	return nil
}
func (this *NewState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewState)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.LAState.Equal(that1.LAState) {
		return false
	}
	return true
}
func (this *NewStateReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewStateReply)
	if !ok {
		return fmt.Errorf("that is not of type *NewStateReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewStateReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewStateReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *NewStateReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewStateReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *CV) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CV)
	if !ok {
		return fmt.Errorf("that is not of type *CV")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CV but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CV but is not nil && this == nil")
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	if !this.Val.Equal(that1.Val) {
		return fmt.Errorf("Val this(%v) Not Equal that(%v)", this.Val, that1.Val)
	}
	return nil
}
func (this *CV) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CV)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	return true
}
func (this *Prepare) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Prepare)
	if !ok {
		return fmt.Errorf("that is not of type *Prepare")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Prepare but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Prepare but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	return nil
}
func (this *Prepare) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Prepare)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	return true
}
func (this *Promise) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Promise)
	if !ok {
		return fmt.Errorf("that is not of type *Promise")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Promise but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Promise but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	if !this.Val.Equal(that1.Val) {
		return fmt.Errorf("Val this(%v) Not Equal that(%v)", this.Val, that1.Val)
	}
	if !this.Dec.Equal(that1.Dec) {
		return fmt.Errorf("Dec this(%v) Not Equal that(%v)", this.Dec, that1.Dec)
	}
	return nil
}
func (this *Promise) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Promise)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	if !this.Dec.Equal(that1.Dec) {
		return false
	}
	return true
}
func (this *Propose) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Propose)
	if !ok {
		return fmt.Errorf("that is not of type *Propose")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Propose but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Propose but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if !this.Val.Equal(that1.Val) {
		return fmt.Errorf("Val this(%v) Not Equal that(%v)", this.Val, that1.Val)
	}
	return nil
}
func (this *Propose) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Propose)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	return true
}
func (this *Learn) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Learn)
	if !ok {
		return fmt.Errorf("that is not of type *Learn")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Learn but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Learn but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.Dec.Equal(that1.Dec) {
		return fmt.Errorf("Dec this(%v) Not Equal that(%v)", this.Dec, that1.Dec)
	}
	if this.Learned != that1.Learned {
		return fmt.Errorf("Learned this(%v) Not Equal that(%v)", this.Learned, that1.Learned)
	}
	return nil
}
func (this *Learn) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Learn)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.Dec.Equal(that1.Dec) {
		return false
	}
	if this.Learned != that1.Learned {
		return false
	}
	return true
}
func (this *Proposal) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Proposal)
	if !ok {
		return fmt.Errorf("that is not of type *Proposal")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Proposal but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Proposal but is not nil && this == nil")
	}
	if !this.Prop.Equal(that1.Prop) {
		return fmt.Errorf("Prop this(%v) Not Equal that(%v)", this.Prop, that1.Prop)
	}
	return nil
}
func (this *Proposal) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Proposal)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Prop.Equal(that1.Prop) {
		return false
	}
	return true
}
func (this *Ack) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Ack)
	if !ok {
		return fmt.Errorf("that is not of type *Ack")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Ack but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Ack but is not nil && this == nil")
	}
	return nil
}
func (this *Ack) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Ack)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetOne) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetOne)
	if !ok {
		return fmt.Errorf("that is not of type *GetOne")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetOne but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetOne but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	if !this.Next.Equal(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", this.Next, that1.Next)
	}
	return nil
}
func (this *GetOne) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetOne)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	if !this.Next.Equal(that1.Next) {
		return false
	}
	return true
}
func (this *GetOneReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetOneReply)
	if !ok {
		return fmt.Errorf("that is not of type *GetOneReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetOneReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetOneReply but is not nil && this == nil")
	}
	if !this.Next.Equal(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", this.Next, that1.Next)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	return nil
}
func (this *GetOneReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetOneReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Next.Equal(that1.Next) {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	return true
}
func (this *DRead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DRead)
	if !ok {
		return fmt.Errorf("that is not of type *DRead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DRead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DRead but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	if !this.Prop.Equal(that1.Prop) {
		return fmt.Errorf("Prop this(%v) Not Equal that(%v)", this.Prop, that1.Prop)
	}
	return nil
}
func (this *DRead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DRead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	if !this.Prop.Equal(that1.Prop) {
		return false
	}
	return true
}
func (this *DReadReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DReadReply)
	if !ok {
		return fmt.Errorf("that is not of type *DReadReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DReadReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DReadReply but is not nil && this == nil")
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *DReadReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DReadReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *DNewState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DNewState)
	if !ok {
		return fmt.Errorf("that is not of type *DNewState")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DNewState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DNewState but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	return nil
}
func (this *DNewState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DNewState)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	return true
}
func (this *DWriteNs) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DWriteNs)
	if !ok {
		return fmt.Errorf("that is not of type *DWriteNs")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DWriteNs but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DWriteNs but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *DWriteNs) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DWriteNs)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *DWriteNsReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DWriteNsReply)
	if !ok {
		return fmt.Errorf("that is not of type *DWriteNsReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DWriteNsReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DWriteNsReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *DWriteNsReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DWriteNsReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *SWriteN) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SWriteN)
	if !ok {
		return fmt.Errorf("that is not of type *SWriteN")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SWriteN but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SWriteN but is not nil && this == nil")
	}
	if this.CurL != that1.CurL {
		return fmt.Errorf("CurL this(%v) Not Equal that(%v)", this.CurL, that1.CurL)
	}
	if this.This != that1.This {
		return fmt.Errorf("This this(%v) Not Equal that(%v)", this.This, that1.This)
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	if !this.Prop.Equal(that1.Prop) {
		return fmt.Errorf("Prop this(%v) Not Equal that(%v)", this.Prop, that1.Prop)
	}
	return nil
}
func (this *SWriteN) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SWriteN)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurL != that1.CurL {
		return false
	}
	if this.This != that1.This {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Prop.Equal(that1.Prop) {
		return false
	}
	return true
}
func (this *SWriteNReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SWriteNReply)
	if !ok {
		return fmt.Errorf("that is not of type *SWriteNReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SWriteNReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SWriteNReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	return nil
}
func (this *SWriteNReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SWriteNReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	return true
}
func (this *Commit) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Commit)
	if !ok {
		return fmt.Errorf("that is not of type *Commit")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Commit but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Commit but is not nil && this == nil")
	}
	if this.CurL != that1.CurL {
		return fmt.Errorf("CurL this(%v) Not Equal that(%v)", this.CurL, that1.CurL)
	}
	if this.This != that1.This {
		return fmt.Errorf("This this(%v) Not Equal that(%v)", this.This, that1.This)
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	if this.Commit != that1.Commit {
		return fmt.Errorf("Commit this(%v) Not Equal that(%v)", this.Commit, that1.Commit)
	}
	if !this.Collect.Equal(that1.Collect) {
		return fmt.Errorf("Collect this(%v) Not Equal that(%v)", this.Collect, that1.Collect)
	}
	return nil
}
func (this *Commit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Commit)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurL != that1.CurL {
		return false
	}
	if this.This != that1.This {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if this.Commit != that1.Commit {
		return false
	}
	if !this.Collect.Equal(that1.Collect) {
		return false
	}
	return true
}
func (this *CommitReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CommitReply)
	if !ok {
		return fmt.Errorf("that is not of type *CommitReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CommitReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CommitReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.Committed.Equal(that1.Committed) {
		return fmt.Errorf("Committed this(%v) Not Equal that(%v)", this.Committed, that1.Committed)
	}
	if !this.Collected.Equal(that1.Collected) {
		return fmt.Errorf("Collected this(%v) Not Equal that(%v)", this.Collected, that1.Collected)
	}
	return nil
}
func (this *CommitReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommitReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.Committed.Equal(that1.Committed) {
		return false
	}
	if !this.Collected.Equal(that1.Collected) {
		return false
	}
	return true
}
func (this *SState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SState)
	if !ok {
		return fmt.Errorf("that is not of type *SState")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SState but is not nil && this == nil")
	}
	if this.CurL != that1.CurL {
		return fmt.Errorf("CurL this(%v) Not Equal that(%v)", this.CurL, that1.CurL)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	return nil
}
func (this *SState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SState)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurL != that1.CurL {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	return true
}
func (this *SStateReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SStateReply)
	if !ok {
		return fmt.Errorf("that is not of type *SStateReply")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SStateReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SStateReply but is not nil && this == nil")
	}
	if this.HasNext != that1.HasNext {
		return fmt.Errorf("HasNext this(%v) Not Equal that(%v)", this.HasNext, that1.HasNext)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	return nil
}
func (this *SStateReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SStateReply)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HasNext != that1.HasNext {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	return true
}

/* Manager type struct */

// Manager manages a pool of machine configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.RWMutex
	machines       []*Machine
	configs        []*Configuration
	machineGidToID map[uint32]int
	configGidToID  map[uint32]int

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions

	aReadSqf     AReadSQuorumFn
	aWriteSqf    AWriteSQuorumFn
	aWriteNqf    AWriteNQuorumFn
	setCurqf     SetCurQuorumFn
	lAPropqf     LAPropQuorumFn
	setStateqf   SetStateQuorumFn
	getPromiseqf GetPromiseQuorumFn
	acceptqf     AcceptQuorumFn
	fwdqf        FwdQuorumFn
	getOneNqf    GetOneNQuorumFn
	dWriteNqf    DWriteNQuorumFn
	dSetStateqf  DSetStateQuorumFn
	dWriteNSetqf DWriteNSetQuorumFn
	dSetCurqf    DSetCurQuorumFn
	spSnOneqf    SpSnOneQuorumFn
	sCommitqf    SCommitQuorumFn
	sSetStateqf  SSetStateQuorumFn
	sSetCurqf    SSetCurQuorumFn
}

/* Manager quorum functions */

func (m *Manager) setDefaultQuorumFuncs() {
	if m.opts.aReadSqf != nil {
		m.aReadSqf = m.opts.aReadSqf
	} else {
		m.aReadSqf = func(c *Configuration, replies []*ReadReply) (*ReadReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.aWriteSqf != nil {
		m.aWriteSqf = m.opts.aWriteSqf
	} else {
		m.aWriteSqf = func(c *Configuration, replies []*ConfReply) (*ConfReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.aWriteNqf != nil {
		m.aWriteNqf = m.opts.aWriteNqf
	} else {
		m.aWriteNqf = func(c *Configuration, replies []*WriteNReply) (*WriteNReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.setCurqf != nil {
		m.setCurqf = m.opts.setCurqf
	} else {
		m.setCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.lAPropqf != nil {
		m.lAPropqf = m.opts.lAPropqf
	} else {
		m.lAPropqf = func(c *Configuration, replies []*LAReply) (*LAReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.setStateqf != nil {
		m.setStateqf = m.opts.setStateqf
	} else {
		m.setStateqf = func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.getPromiseqf != nil {
		m.getPromiseqf = m.opts.getPromiseqf
	} else {
		m.getPromiseqf = func(c *Configuration, replies []*Promise) (*Promise, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.acceptqf != nil {
		m.acceptqf = m.opts.acceptqf
	} else {
		m.acceptqf = func(c *Configuration, replies []*Learn) (*Learn, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.fwdqf != nil {
		m.fwdqf = m.opts.fwdqf
	} else {
		m.fwdqf = func(c *Configuration, replies []*Ack) (*Ack, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.getOneNqf != nil {
		m.getOneNqf = m.opts.getOneNqf
	} else {
		m.getOneNqf = func(c *Configuration, replies []*GetOneReply) (*GetOneReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dWriteNqf != nil {
		m.dWriteNqf = m.opts.dWriteNqf
	} else {
		m.dWriteNqf = func(c *Configuration, replies []*DReadReply) (*DReadReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dSetStateqf != nil {
		m.dSetStateqf = m.opts.dSetStateqf
	} else {
		m.dSetStateqf = func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dWriteNSetqf != nil {
		m.dWriteNSetqf = m.opts.dWriteNSetqf
	} else {
		m.dWriteNSetqf = func(c *Configuration, replies []*DWriteNsReply) (*DWriteNsReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.dSetCurqf != nil {
		m.dSetCurqf = m.opts.dSetCurqf
	} else {
		m.dSetCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.spSnOneqf != nil {
		m.spSnOneqf = m.opts.spSnOneqf
	} else {
		m.spSnOneqf = func(c *Configuration, replies []*SWriteNReply) (*SWriteNReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.sCommitqf != nil {
		m.sCommitqf = m.opts.sCommitqf
	} else {
		m.sCommitqf = func(c *Configuration, replies []*CommitReply) (*CommitReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.sSetStateqf != nil {
		m.sSetStateqf = m.opts.sSetStateqf
	} else {
		m.sSetStateqf = func(c *Configuration, replies []*SStateReply) (*SStateReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
	if m.opts.sSetCurqf != nil {
		m.sSetCurqf = m.opts.sSetCurqf
	} else {
		m.sSetCurqf = func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool) {
			if len(replies) < c.Quorum() {
				return nil, false
			}
			return replies[0], true
		}
	}
}

/* Manager create/close streams */

func (m *Manager) createStreamClients() error {
	if m.opts.noConnect {
		return nil
	}

	return nil
}

func (m *Manager) closeStreamClients() {
	if m.opts.noConnect {
		return
	}

}

/* Manager options */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool

	aReadSqf     AReadSQuorumFn
	aWriteSqf    AWriteSQuorumFn
	aWriteNqf    AWriteNQuorumFn
	setCurqf     SetCurQuorumFn
	lAPropqf     LAPropQuorumFn
	setStateqf   SetStateQuorumFn
	getPromiseqf GetPromiseQuorumFn
	acceptqf     AcceptQuorumFn
	fwdqf        FwdQuorumFn
	getOneNqf    GetOneNQuorumFn
	dWriteNqf    DWriteNQuorumFn
	dSetStateqf  DSetStateQuorumFn
	dWriteNSetqf DWriteNSetQuorumFn
	dSetCurqf    DSetCurQuorumFn
	spSnOneqf    SpSnOneQuorumFn
	sCommitqf    SCommitQuorumFn
	sSetStateqf  SSetStateQuorumFn
	sSetCurqf    SSetCurQuorumFn
}

// WithAReadSQuorumFunc returns a ManagerOption that sets a cumstom
// AReadSQuorumFunc.
func WithAReadSQuorumFunc(f AReadSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aReadSqf = f
	}
}

// WithAWriteSQuorumFunc returns a ManagerOption that sets a cumstom
// AWriteSQuorumFunc.
func WithAWriteSQuorumFunc(f AWriteSQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aWriteSqf = f
	}
}

// WithAWriteNQuorumFunc returns a ManagerOption that sets a cumstom
// AWriteNQuorumFunc.
func WithAWriteNQuorumFunc(f AWriteNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.aWriteNqf = f
	}
}

// WithSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// SetCurQuorumFunc.
func WithSetCurQuorumFunc(f SetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.setCurqf = f
	}
}

// WithLAPropQuorumFunc returns a ManagerOption that sets a cumstom
// LAPropQuorumFunc.
func WithLAPropQuorumFunc(f LAPropQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.lAPropqf = f
	}
}

// WithSetStateQuorumFunc returns a ManagerOption that sets a cumstom
// SetStateQuorumFunc.
func WithSetStateQuorumFunc(f SetStateQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.setStateqf = f
	}
}

// WithGetPromiseQuorumFunc returns a ManagerOption that sets a cumstom
// GetPromiseQuorumFunc.
func WithGetPromiseQuorumFunc(f GetPromiseQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.getPromiseqf = f
	}
}

// WithAcceptQuorumFunc returns a ManagerOption that sets a cumstom
// AcceptQuorumFunc.
func WithAcceptQuorumFunc(f AcceptQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.acceptqf = f
	}
}

// WithFwdQuorumFunc returns a ManagerOption that sets a cumstom
// FwdQuorumFunc.
func WithFwdQuorumFunc(f FwdQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.fwdqf = f
	}
}

// WithGetOneNQuorumFunc returns a ManagerOption that sets a cumstom
// GetOneNQuorumFunc.
func WithGetOneNQuorumFunc(f GetOneNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.getOneNqf = f
	}
}

// WithDWriteNQuorumFunc returns a ManagerOption that sets a cumstom
// DWriteNQuorumFunc.
func WithDWriteNQuorumFunc(f DWriteNQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dWriteNqf = f
	}
}

// WithDSetStateQuorumFunc returns a ManagerOption that sets a cumstom
// DSetStateQuorumFunc.
func WithDSetStateQuorumFunc(f DSetStateQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dSetStateqf = f
	}
}

// WithDWriteNSetQuorumFunc returns a ManagerOption that sets a cumstom
// DWriteNSetQuorumFunc.
func WithDWriteNSetQuorumFunc(f DWriteNSetQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dWriteNSetqf = f
	}
}

// WithDSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// DSetCurQuorumFunc.
func WithDSetCurQuorumFunc(f DSetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.dSetCurqf = f
	}
}

// WithSpSnOneQuorumFunc returns a ManagerOption that sets a cumstom
// SpSnOneQuorumFunc.
func WithSpSnOneQuorumFunc(f SpSnOneQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.spSnOneqf = f
	}
}

// WithSCommitQuorumFunc returns a ManagerOption that sets a cumstom
// SCommitQuorumFunc.
func WithSCommitQuorumFunc(f SCommitQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.sCommitqf = f
	}
}

// WithSSetStateQuorumFunc returns a ManagerOption that sets a cumstom
// SSetStateQuorumFunc.
func WithSSetStateQuorumFunc(f SSetStateQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.sSetStateqf = f
	}
}

// WithSSetCurQuorumFunc returns a ManagerOption that sets a cumstom
// SSetCurQuorumFunc.
func WithSSetCurQuorumFunc(f SSetCurQuorumFn) ManagerOption {
	return func(o *managerOptions) {
		o.sSetCurqf = f
	}
}

// AReadSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AReadSQuorumFn func(c *Configuration, replies []*ReadReply) (*ReadReply, bool)

// AWriteSQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AWriteSQuorumFn func(c *Configuration, replies []*ConfReply) (*ConfReply, bool)

// AWriteNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AWriteNQuorumFn func(c *Configuration, replies []*WriteNReply) (*WriteNReply, bool)

// SetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

// LAPropQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type LAPropQuorumFn func(c *Configuration, replies []*LAReply) (*LAReply, bool)

// SetStateQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SetStateQuorumFn func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool)

// GetPromiseQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type GetPromiseQuorumFn func(c *Configuration, replies []*Promise) (*Promise, bool)

// AcceptQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type AcceptQuorumFn func(c *Configuration, replies []*Learn) (*Learn, bool)

// FwdQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type FwdQuorumFn func(c *Configuration, replies []*Ack) (*Ack, bool)

// GetOneNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type GetOneNQuorumFn func(c *Configuration, replies []*GetOneReply) (*GetOneReply, bool)

// DWriteNQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DWriteNQuorumFn func(c *Configuration, replies []*DReadReply) (*DReadReply, bool)

// DSetStateQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DSetStateQuorumFn func(c *Configuration, replies []*NewStateReply) (*NewStateReply, bool)

// DWriteNSetQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DWriteNSetQuorumFn func(c *Configuration, replies []*DWriteNsReply) (*DWriteNsReply, bool)

// DSetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type DSetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

// SpSnOneQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SpSnOneQuorumFn func(c *Configuration, replies []*SWriteNReply) (*SWriteNReply, bool)

// SCommitQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SCommitQuorumFn func(c *Configuration, replies []*CommitReply) (*CommitReply, bool)

// SSetStateQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SSetStateQuorumFn func(c *Configuration, replies []*SStateReply) (*SStateReply, bool)

// SSetCurQuorumFn is used to pick a reply from the replies if there is a quorum.
// If there was not enough replies to satisfy the quorum requirement,
// then the function returns (nil, false). Otherwise, the function picks a
// reply among the replies and returns (reply, true).
type SSetCurQuorumFn func(c *Configuration, replies []*NewCurReply) (*NewCurReply, bool)

/* Gorums Client API */

/* Configuration RPC specific */

// AReadSReply encapsulates the reply from a AReadS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AReadSReply struct {
	MachineIDs []int
	Reply      *ReadReply
}

func (r AReadSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AReadSReply invokes a AReadS RPC on configuration c
// and returns the result as a AReadSReply.
func (c *Configuration) AReadS(args *Conf) (*AReadSReply, error) {
	return c.mgr.aReadS(c.id, args)
}

// AReadSFuture is a reference to an asynchronous AReadS RPC invocation.
type AReadSFuture struct {
	reply *AReadSReply
	err   error
	c     chan struct{}
}

// AReadSFuture asynchronously invokes a AReadS RPC on configuration c and
// returns a AReadSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AReadSFuture(args *Conf) *AReadSFuture {
	f := new(AReadSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aReadS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AReadSFuture.
// The method blocks until a reply or error is available.
func (f *AReadSFuture) Get() (*AReadSReply, error) {
	<-f.c
	return f.reply, f.err
}

// AWriteSReply encapsulates the reply from a AWriteS RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AWriteSReply struct {
	MachineIDs []int
	Reply      *ConfReply
}

func (r AWriteSReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AWriteSReply invokes a AWriteS RPC on configuration c
// and returns the result as a AWriteSReply.
func (c *Configuration) AWriteS(args *WriteS) (*AWriteSReply, error) {
	return c.mgr.aWriteS(c.id, args)
}

// AWriteSFuture is a reference to an asynchronous AWriteS RPC invocation.
type AWriteSFuture struct {
	reply *AWriteSReply
	err   error
	c     chan struct{}
}

// AWriteSFuture asynchronously invokes a AWriteS RPC on configuration c and
// returns a AWriteSFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AWriteSFuture(args *WriteS) *AWriteSFuture {
	f := new(AWriteSFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aWriteS(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AWriteSFuture.
// The method blocks until a reply or error is available.
func (f *AWriteSFuture) Get() (*AWriteSReply, error) {
	<-f.c
	return f.reply, f.err
}

// AWriteNReply encapsulates the reply from a AWriteN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AWriteNReply struct {
	MachineIDs []int
	Reply      *WriteNReply
}

func (r AWriteNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AWriteNReply invokes a AWriteN RPC on configuration c
// and returns the result as a AWriteNReply.
func (c *Configuration) AWriteN(args *WriteN) (*AWriteNReply, error) {
	return c.mgr.aWriteN(c.id, args)
}

// AWriteNFuture is a reference to an asynchronous AWriteN RPC invocation.
type AWriteNFuture struct {
	reply *AWriteNReply
	err   error
	c     chan struct{}
}

// AWriteNFuture asynchronously invokes a AWriteN RPC on configuration c and
// returns a AWriteNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AWriteNFuture(args *WriteN) *AWriteNFuture {
	f := new(AWriteNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.aWriteN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AWriteNFuture.
// The method blocks until a reply or error is available.
func (f *AWriteNFuture) Get() (*AWriteNReply, error) {
	<-f.c
	return f.reply, f.err
}

// SetCurReply encapsulates the reply from a SetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SetCurReply struct {
	MachineIDs []int
	Reply      *NewCurReply
}

func (r SetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SetCurReply invokes a SetCur RPC on configuration c
// and returns the result as a SetCurReply.
func (c *Configuration) SetCur(args *NewCur) (*SetCurReply, error) {
	return c.mgr.setCur(c.id, args)
}

// SetCurFuture is a reference to an asynchronous SetCur RPC invocation.
type SetCurFuture struct {
	reply *SetCurReply
	err   error
	c     chan struct{}
}

// SetCurFuture asynchronously invokes a SetCur RPC on configuration c and
// returns a SetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SetCurFuture(args *NewCur) *SetCurFuture {
	f := new(SetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.setCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SetCurFuture.
// The method blocks until a reply or error is available.
func (f *SetCurFuture) Get() (*SetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

// LAPropReply encapsulates the reply from a LAProp RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type LAPropReply struct {
	MachineIDs []int
	Reply      *LAReply
}

func (r LAPropReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// LAPropReply invokes a LAProp RPC on configuration c
// and returns the result as a LAPropReply.
func (c *Configuration) LAProp(args *LAProposal) (*LAPropReply, error) {
	return c.mgr.lAProp(c.id, args)
}

// LAPropFuture is a reference to an asynchronous LAProp RPC invocation.
type LAPropFuture struct {
	reply *LAPropReply
	err   error
	c     chan struct{}
}

// LAPropFuture asynchronously invokes a LAProp RPC on configuration c and
// returns a LAPropFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) LAPropFuture(args *LAProposal) *LAPropFuture {
	f := new(LAPropFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.lAProp(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the LAPropFuture.
// The method blocks until a reply or error is available.
func (f *LAPropFuture) Get() (*LAPropReply, error) {
	<-f.c
	return f.reply, f.err
}

// SetStateReply encapsulates the reply from a SetState RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SetStateReply struct {
	MachineIDs []int
	Reply      *NewStateReply
}

func (r SetStateReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SetStateReply invokes a SetState RPC on configuration c
// and returns the result as a SetStateReply.
func (c *Configuration) SetState(args *NewState) (*SetStateReply, error) {
	return c.mgr.setState(c.id, args)
}

// SetStateFuture is a reference to an asynchronous SetState RPC invocation.
type SetStateFuture struct {
	reply *SetStateReply
	err   error
	c     chan struct{}
}

// SetStateFuture asynchronously invokes a SetState RPC on configuration c and
// returns a SetStateFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SetStateFuture(args *NewState) *SetStateFuture {
	f := new(SetStateFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.setState(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SetStateFuture.
// The method blocks until a reply or error is available.
func (f *SetStateFuture) Get() (*SetStateReply, error) {
	<-f.c
	return f.reply, f.err
}

// GetPromiseReply encapsulates the reply from a GetPromise RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type GetPromiseReply struct {
	MachineIDs []int
	Reply      *Promise
}

func (r GetPromiseReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// GetPromiseReply invokes a GetPromise RPC on configuration c
// and returns the result as a GetPromiseReply.
func (c *Configuration) GetPromise(args *Prepare) (*GetPromiseReply, error) {
	return c.mgr.getPromise(c.id, args)
}

// GetPromiseFuture is a reference to an asynchronous GetPromise RPC invocation.
type GetPromiseFuture struct {
	reply *GetPromiseReply
	err   error
	c     chan struct{}
}

// GetPromiseFuture asynchronously invokes a GetPromise RPC on configuration c and
// returns a GetPromiseFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) GetPromiseFuture(args *Prepare) *GetPromiseFuture {
	f := new(GetPromiseFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.getPromise(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the GetPromiseFuture.
// The method blocks until a reply or error is available.
func (f *GetPromiseFuture) Get() (*GetPromiseReply, error) {
	<-f.c
	return f.reply, f.err
}

// AcceptReply encapsulates the reply from a Accept RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type AcceptReply struct {
	MachineIDs []int
	Reply      *Learn
}

func (r AcceptReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// AcceptReply invokes a Accept RPC on configuration c
// and returns the result as a AcceptReply.
func (c *Configuration) Accept(args *Propose) (*AcceptReply, error) {
	return c.mgr.accept(c.id, args)
}

// AcceptFuture is a reference to an asynchronous Accept RPC invocation.
type AcceptFuture struct {
	reply *AcceptReply
	err   error
	c     chan struct{}
}

// AcceptFuture asynchronously invokes a Accept RPC on configuration c and
// returns a AcceptFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) AcceptFuture(args *Propose) *AcceptFuture {
	f := new(AcceptFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.accept(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the AcceptFuture.
// The method blocks until a reply or error is available.
func (f *AcceptFuture) Get() (*AcceptReply, error) {
	<-f.c
	return f.reply, f.err
}

// FwdReply encapsulates the reply from a Fwd RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type FwdReply struct {
	MachineIDs []int
	Reply      *Ack
}

func (r FwdReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// FwdReply invokes a Fwd RPC on configuration c
// and returns the result as a FwdReply.
func (c *Configuration) Fwd(args *Proposal) (*FwdReply, error) {
	return c.mgr.fwd(c.id, args)
}

// FwdFuture is a reference to an asynchronous Fwd RPC invocation.
type FwdFuture struct {
	reply *FwdReply
	err   error
	c     chan struct{}
}

// FwdFuture asynchronously invokes a Fwd RPC on configuration c and
// returns a FwdFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) FwdFuture(args *Proposal) *FwdFuture {
	f := new(FwdFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.fwd(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the FwdFuture.
// The method blocks until a reply or error is available.
func (f *FwdFuture) Get() (*FwdReply, error) {
	<-f.c
	return f.reply, f.err
}

// GetOneNReply encapsulates the reply from a GetOneN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type GetOneNReply struct {
	MachineIDs []int
	Reply      *GetOneReply
}

func (r GetOneNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// GetOneNReply invokes a GetOneN RPC on configuration c
// and returns the result as a GetOneNReply.
func (c *Configuration) GetOneN(args *GetOne) (*GetOneNReply, error) {
	return c.mgr.getOneN(c.id, args)
}

// GetOneNFuture is a reference to an asynchronous GetOneN RPC invocation.
type GetOneNFuture struct {
	reply *GetOneNReply
	err   error
	c     chan struct{}
}

// GetOneNFuture asynchronously invokes a GetOneN RPC on configuration c and
// returns a GetOneNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) GetOneNFuture(args *GetOne) *GetOneNFuture {
	f := new(GetOneNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.getOneN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the GetOneNFuture.
// The method blocks until a reply or error is available.
func (f *GetOneNFuture) Get() (*GetOneNReply, error) {
	<-f.c
	return f.reply, f.err
}

// DWriteNReply encapsulates the reply from a DWriteN RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DWriteNReply struct {
	MachineIDs []int
	Reply      *DReadReply
}

func (r DWriteNReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DWriteNReply invokes a DWriteN RPC on configuration c
// and returns the result as a DWriteNReply.
func (c *Configuration) DWriteN(args *DRead) (*DWriteNReply, error) {
	return c.mgr.dWriteN(c.id, args)
}

// DWriteNFuture is a reference to an asynchronous DWriteN RPC invocation.
type DWriteNFuture struct {
	reply *DWriteNReply
	err   error
	c     chan struct{}
}

// DWriteNFuture asynchronously invokes a DWriteN RPC on configuration c and
// returns a DWriteNFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DWriteNFuture(args *DRead) *DWriteNFuture {
	f := new(DWriteNFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dWriteN(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DWriteNFuture.
// The method blocks until a reply or error is available.
func (f *DWriteNFuture) Get() (*DWriteNReply, error) {
	<-f.c
	return f.reply, f.err
}

// DSetStateReply encapsulates the reply from a DSetState RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DSetStateReply struct {
	MachineIDs []int
	Reply      *NewStateReply
}

func (r DSetStateReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DSetStateReply invokes a DSetState RPC on configuration c
// and returns the result as a DSetStateReply.
func (c *Configuration) DSetState(args *DNewState) (*DSetStateReply, error) {
	return c.mgr.dSetState(c.id, args)
}

// DSetStateFuture is a reference to an asynchronous DSetState RPC invocation.
type DSetStateFuture struct {
	reply *DSetStateReply
	err   error
	c     chan struct{}
}

// DSetStateFuture asynchronously invokes a DSetState RPC on configuration c and
// returns a DSetStateFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DSetStateFuture(args *DNewState) *DSetStateFuture {
	f := new(DSetStateFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dSetState(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DSetStateFuture.
// The method blocks until a reply or error is available.
func (f *DSetStateFuture) Get() (*DSetStateReply, error) {
	<-f.c
	return f.reply, f.err
}

// DWriteNSetReply encapsulates the reply from a DWriteNSet RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DWriteNSetReply struct {
	MachineIDs []int
	Reply      *DWriteNsReply
}

func (r DWriteNSetReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DWriteNSetReply invokes a DWriteNSet RPC on configuration c
// and returns the result as a DWriteNSetReply.
func (c *Configuration) DWriteNSet(args *DWriteNs) (*DWriteNSetReply, error) {
	return c.mgr.dWriteNSet(c.id, args)
}

// DWriteNSetFuture is a reference to an asynchronous DWriteNSet RPC invocation.
type DWriteNSetFuture struct {
	reply *DWriteNSetReply
	err   error
	c     chan struct{}
}

// DWriteNSetFuture asynchronously invokes a DWriteNSet RPC on configuration c and
// returns a DWriteNSetFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DWriteNSetFuture(args *DWriteNs) *DWriteNSetFuture {
	f := new(DWriteNSetFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dWriteNSet(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DWriteNSetFuture.
// The method blocks until a reply or error is available.
func (f *DWriteNSetFuture) Get() (*DWriteNSetReply, error) {
	<-f.c
	return f.reply, f.err
}

// DSetCurReply encapsulates the reply from a DSetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type DSetCurReply struct {
	MachineIDs []int
	Reply      *NewCurReply
}

func (r DSetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// DSetCurReply invokes a DSetCur RPC on configuration c
// and returns the result as a DSetCurReply.
func (c *Configuration) DSetCur(args *NewCur) (*DSetCurReply, error) {
	return c.mgr.dSetCur(c.id, args)
}

// DSetCurFuture is a reference to an asynchronous DSetCur RPC invocation.
type DSetCurFuture struct {
	reply *DSetCurReply
	err   error
	c     chan struct{}
}

// DSetCurFuture asynchronously invokes a DSetCur RPC on configuration c and
// returns a DSetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) DSetCurFuture(args *NewCur) *DSetCurFuture {
	f := new(DSetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.dSetCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the DSetCurFuture.
// The method blocks until a reply or error is available.
func (f *DSetCurFuture) Get() (*DSetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

// SpSnOneReply encapsulates the reply from a SpSnOne RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SpSnOneReply struct {
	MachineIDs []int
	Reply      *SWriteNReply
}

func (r SpSnOneReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SpSnOneReply invokes a SpSnOne RPC on configuration c
// and returns the result as a SpSnOneReply.
func (c *Configuration) SpSnOne(args *SWriteN) (*SpSnOneReply, error) {
	return c.mgr.spSnOne(c.id, args)
}

// SpSnOneFuture is a reference to an asynchronous SpSnOne RPC invocation.
type SpSnOneFuture struct {
	reply *SpSnOneReply
	err   error
	c     chan struct{}
}

// SpSnOneFuture asynchronously invokes a SpSnOne RPC on configuration c and
// returns a SpSnOneFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SpSnOneFuture(args *SWriteN) *SpSnOneFuture {
	f := new(SpSnOneFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.spSnOne(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SpSnOneFuture.
// The method blocks until a reply or error is available.
func (f *SpSnOneFuture) Get() (*SpSnOneReply, error) {
	<-f.c
	return f.reply, f.err
}

// SCommitReply encapsulates the reply from a SCommit RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SCommitReply struct {
	MachineIDs []int
	Reply      *CommitReply
}

func (r SCommitReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SCommitReply invokes a SCommit RPC on configuration c
// and returns the result as a SCommitReply.
func (c *Configuration) SCommit(args *Commit) (*SCommitReply, error) {
	return c.mgr.sCommit(c.id, args)
}

// SCommitFuture is a reference to an asynchronous SCommit RPC invocation.
type SCommitFuture struct {
	reply *SCommitReply
	err   error
	c     chan struct{}
}

// SCommitFuture asynchronously invokes a SCommit RPC on configuration c and
// returns a SCommitFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SCommitFuture(args *Commit) *SCommitFuture {
	f := new(SCommitFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.sCommit(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SCommitFuture.
// The method blocks until a reply or error is available.
func (f *SCommitFuture) Get() (*SCommitReply, error) {
	<-f.c
	return f.reply, f.err
}

// SSetStateReply encapsulates the reply from a SSetState RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SSetStateReply struct {
	MachineIDs []int
	Reply      *SStateReply
}

func (r SSetStateReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SSetStateReply invokes a SSetState RPC on configuration c
// and returns the result as a SSetStateReply.
func (c *Configuration) SSetState(args *SState) (*SSetStateReply, error) {
	return c.mgr.sSetState(c.id, args)
}

// SSetStateFuture is a reference to an asynchronous SSetState RPC invocation.
type SSetStateFuture struct {
	reply *SSetStateReply
	err   error
	c     chan struct{}
}

// SSetStateFuture asynchronously invokes a SSetState RPC on configuration c and
// returns a SSetStateFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SSetStateFuture(args *SState) *SSetStateFuture {
	f := new(SSetStateFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.sSetState(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SSetStateFuture.
// The method blocks until a reply or error is available.
func (f *SSetStateFuture) Get() (*SSetStateReply, error) {
	<-f.c
	return f.reply, f.err
}

// SSetCurReply encapsulates the reply from a SSetCur RPC invocation.
// It contains the id of each machine in the quorum that replied and a single
// reply.
type SSetCurReply struct {
	MachineIDs []int
	Reply      *NewCurReply
}

func (r SSetCurReply) String() string {
	return fmt.Sprintf("Machine IDs: %v | Answer: %v", r.MachineIDs, r.Reply)
}

// SSetCurReply invokes a SSetCur RPC on configuration c
// and returns the result as a SSetCurReply.
func (c *Configuration) SSetCur(args *NewCur) (*SSetCurReply, error) {
	return c.mgr.sSetCur(c.id, args)
}

// SSetCurFuture is a reference to an asynchronous SSetCur RPC invocation.
type SSetCurFuture struct {
	reply *SSetCurReply
	err   error
	c     chan struct{}
}

// SSetCurFuture asynchronously invokes a SSetCur RPC on configuration c and
// returns a SSetCurFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) SSetCurFuture(args *NewCur) *SSetCurFuture {
	f := new(SSetCurFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.sSetCur(c.id, args)
	}()
	return f
}

// Get returns the reply and any error associated with the SSetCurFuture.
// The method blocks until a reply or error is available.
func (f *SSetCurFuture) Get() (*SSetCurReply, error) {
	<-f.c
	return f.reply, f.err
}

/* Manager RPC specific */

type aReadSReply struct {
	mid   int
	reply *ReadReply
	err   error
}

func (m *Manager) aReadS(cid int, args *Conf) (*AReadSReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan aReadSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*ReadReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AReadSReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(ReadReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/AReadS",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aReadSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.aReadSqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type aWriteSReply struct {
	mid   int
	reply *ConfReply
	err   error
}

func (m *Manager) aWriteS(cid int, args *WriteS) (*AWriteSReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan aWriteSReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*ConfReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AWriteSReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(ConfReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/AWriteS",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aWriteSReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.aWriteSqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type aWriteNReply struct {
	mid   int
	reply *WriteNReply
	err   error
}

func (m *Manager) aWriteN(cid int, args *WriteN) (*AWriteNReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan aWriteNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*WriteNReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AWriteNReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(WriteNReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/AWriteN",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- aWriteNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.aWriteNqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type setCurReply struct {
	mid   int
	reply *NewCurReply
	err   error
}

func (m *Manager) setCur(cid int, args *NewCur) (*SetCurReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan setCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SetCurReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/SetCur",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- setCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.setCurqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type lAPropReply struct {
	mid   int
	reply *LAReply
	err   error
}

func (m *Manager) lAProp(cid int, args *LAProposal) (*LAPropReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan lAPropReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*LAReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &LAPropReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(LAReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/LAProp",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- lAPropReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.lAPropqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type setStateReply struct {
	mid   int
	reply *NewStateReply
	err   error
}

func (m *Manager) setState(cid int, args *NewState) (*SetStateReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan setStateReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewStateReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SetStateReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewStateReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/SetState",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- setStateReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.setStateqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type getPromiseReply struct {
	mid   int
	reply *Promise
	err   error
}

func (m *Manager) getPromise(cid int, args *Prepare) (*GetPromiseReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan getPromiseReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Promise, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &GetPromiseReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(Promise)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/GetPromise",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- getPromiseReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.getPromiseqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type acceptReply struct {
	mid   int
	reply *Learn
	err   error
}

func (m *Manager) accept(cid int, args *Propose) (*AcceptReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan acceptReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Learn, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &AcceptReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(Learn)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/Accept",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- acceptReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.acceptqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type fwdReply struct {
	mid   int
	reply *Ack
	err   error
}

func (m *Manager) fwd(cid int, args *Proposal) (*FwdReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan fwdReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*Ack, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &FwdReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(Ack)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.AdvRegister/Fwd",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- fwdReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.fwdqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type getOneNReply struct {
	mid   int
	reply *GetOneReply
	err   error
}

func (m *Manager) getOneN(cid int, args *GetOne) (*GetOneNReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan getOneNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*GetOneReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &GetOneNReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(GetOneReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/GetOneN",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- getOneNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.getOneNqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dWriteNReply struct {
	mid   int
	reply *DReadReply
	err   error
}

func (m *Manager) dWriteN(cid int, args *DRead) (*DWriteNReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dWriteNReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*DReadReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DWriteNReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(DReadReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DWriteN",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dWriteNReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dWriteNqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dSetStateReply struct {
	mid   int
	reply *NewStateReply
	err   error
}

func (m *Manager) dSetState(cid int, args *DNewState) (*DSetStateReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dSetStateReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewStateReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DSetStateReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewStateReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DSetState",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dSetStateReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dSetStateqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dWriteNSetReply struct {
	mid   int
	reply *DWriteNsReply
	err   error
}

func (m *Manager) dWriteNSet(cid int, args *DWriteNs) (*DWriteNSetReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dWriteNSetReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*DWriteNsReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DWriteNSetReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(DWriteNsReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DWriteNSet",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dWriteNSetReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dWriteNSetqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type dSetCurReply struct {
	mid   int
	reply *NewCurReply
	err   error
}

func (m *Manager) dSetCur(cid int, args *NewCur) (*DSetCurReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan dSetCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &DSetCurReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.DynaDisk/DSetCur",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- dSetCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.dSetCurqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type spSnOneReply struct {
	mid   int
	reply *SWriteNReply
	err   error
}

func (m *Manager) spSnOne(cid int, args *SWriteN) (*SpSnOneReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan spSnOneReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*SWriteNReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SpSnOneReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(SWriteNReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.SpSnRegister/SpSnOne",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- spSnOneReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.spSnOneqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type sCommitReply struct {
	mid   int
	reply *CommitReply
	err   error
}

func (m *Manager) sCommit(cid int, args *Commit) (*SCommitReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan sCommitReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*CommitReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SCommitReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(CommitReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.SpSnRegister/SCommit",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- sCommitReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.sCommitqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type sSetStateReply struct {
	mid   int
	reply *SStateReply
	err   error
}

func (m *Manager) sSetState(cid int, args *SState) (*SSetStateReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan sSetStateReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*SStateReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SSetStateReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(SStateReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.SpSnRegister/SSetState",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- sSetStateReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.sSetStateqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

type sSetCurReply struct {
	mid   int
	reply *NewCurReply
	err   error
}

func (m *Manager) sSetCur(cid int, args *NewCur) (*SSetCurReply, error) {
	c, found := m.Configuration(cid)
	if !found {
		panic("execptional: config not found")
	}

	var (
		replyChan   = make(chan sSetCurReply, c.quorum)
		stopSignal  = make(chan struct{})
		replyValues = make([]*NewCurReply, 0, c.quorum)
		errCount    int
		quorum      bool
		reply       = &SSetCurReply{MachineIDs: make([]int, 0, c.quorum)}
	)

	for _, mid := range c.machines {
		machine, found := m.Machine(mid)
		if !found {
			panic("exceptional: machine not found")
		}
		go func() {
			reply := new(NewCurReply)
			ce := make(chan error, 1)
			start := time.Now()
			go func() {
				select {
				case ce <- grpc.Invoke(
					c.defCtx,
					"/proto.SpSnRegister/SSetCur",
					args,
					reply,
					machine.conn,
				):
				case <-stopSignal:
					return
				}
			}()
			select {
			case err := <-ce:
				switch grpc.Code(err) {
				case codes.OK, codes.Aborted, codes.Canceled:
					machine.setLatency(time.Since(start))
				default:
					machine.setLastErr(err)
				}
				replyChan <- sSetCurReply{machine.id, reply, err}
			case <-stopSignal:
				return
			}
		}()
	}

	defer close(stopSignal)

	for {

		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}

			replyValues = append(replyValues, r.reply)
			reply.MachineIDs = append(reply.MachineIDs, r.mid)
			if reply.Reply, quorum = m.sSetCurqf(c, replyValues); quorum {
				return reply, nil
			}
		case <-time.After(c.timeout):
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.Size() {
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of machines on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id       int
	gid      uint32
	machines []int
	mgr      *Manager
	quorum   int
	timeout  time.Duration
	defCtx   context.Context
}

// ID reports the local identifier for the configuration.
func (c *Configuration) ID() int {
	return c.id
}

// GlobalID reports the unique global identifier for the configuration.
func (c *Configuration) GlobalID() uint32 {
	return c.gid
}

// Machines returns a slice containing the local ids of all the machines in the
// configuration.
func (c *Configuration) Machines() []int { return c.machines }

// Quorum returns the quourm size for the configuration.
func (c *Configuration) Quorum() int {
	return c.quorum
}

// Size returns the number of machines in the configuration.
func (c *Configuration) Size() int {
	return len(c.machines)
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d | gid: %d", c.id, c.gid)
}

// Equal retuns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.gid == b.gid }

// NewTestConfiguration returns a new configuration with quorum size q and
// machine size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		quorum:   q,
		machines: make([]int, n),
	}
}

/* errors.go */

// A MachineNotFoundError reports that a specified machine could not be found.
type MachineNotFoundError uint32

func (e MachineNotFoundError) Error() string {
	return fmt.Sprintf("machine not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, RepliesCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.RepliesCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited                 time.Duration
	ErrCount, RepliesCount int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

/* machine.go */

// Machine encapsulates the state of a machine on which a remote procedure call
// can be made.
type Machine struct {
	// Only assigned at creation.
	id   int
	gid  uint32
	addr string
	conn *grpc.ClientConn

	sync.Mutex
	lastErr error
	latency time.Duration
}

// ConnState returns the state of the underlying gRPC client connection.
func (m *Machine) ConnState() grpc.ConnectivityState {
	return m.conn.State()
}

func (m *Machine) String() string {
	m.Lock()
	defer m.Unlock()
	return fmt.Sprintf(
		"machine %d | gid: %d | addr: %s | latency: %v | connstate: %v",
		m.id,
		m.gid,
		m.addr,
		m.latency,
		m.conn.State(),
	)
}

func (m *Machine) setLastErr(err error) {
	m.Lock()
	defer m.Unlock()
	m.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this machine.
func (m *Machine) LastErr() error {
	m.Lock()
	defer m.Unlock()
	return m.lastErr
}

func (m *Machine) setLatency(lat time.Duration) {
	m.Lock()
	defer m.Unlock()
	m.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this machine.
func (m *Machine) Latency() time.Duration {
	m.Lock()
	defer m.Unlock()
	return m.latency
}

// ByID attaches the methods of sort.Interface to []Machine, sorting machines
// by their local identifier in increasing order.
type ByID []*Machine

func (p ByID) Len() int           { return len(p) }
func (p ByID) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
func (p ByID) Less(i, j int) bool { return p[i].id < p[j].id }

// ByGID attaches the methods of sort.Interface to []Machine, sorting machines
// by their global identifier in increasing order.
type ByGID []*Machine

func (p ByGID) Len() int           { return len(p) }
func (p ByGID) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
func (p ByGID) Less(i, j int) bool { return p[i].gid < p[j].gid }

// ByLatency attaches the methods of sort.Interface to []Machine, sorting
// machines by latency in increasing order. Latencies less then zero (sentinel
// value) are considered greater than any positive latency.
type ByLatency []*Machine

func (p ByLatency) Len() int      { return len(p) }
func (p ByLatency) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p ByLatency) Less(i, j int) bool {
	if p[i].latency < 0 {
		return false
	}
	return p[i].latency < p[j].latency
}

/* mgr.go */

// NewManager attempts to connect to the given set of machines addresses and if
// successful returns a new Manager containing connections to those machines.
func NewManager(machineAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(machineAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no machines provided")
	}

	m := new(Manager)
	m.machineGidToID = make(map[uint32]int)
	m.configGidToID = make(map[uint32]int)

	for _, opt := range opts {
		opt(&m.opts)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	for _, maddr := range machineAddrs {
		err := m.createMachine(maddr)
		if err != nil {
			return nil, fmt.Errorf("could not create manager: %v", err)
		}
	}

	err := m.createStreamClients()
	if err != nil {
		return nil, fmt.Errorf("could not create manager: %v", err)
	}

	m.setDefaultQuorumFuncs()

	return m, nil
}

// Close closes all machine connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		m.closeStreamClients()
		m.closeMachineConns()
	})
}

// MachineIDs returns the identifier of each available machine.
func (m *Manager) MachineIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.machines))
	for i := range m.machines {
		ids[i] = i
	}
	return ids
}

// MachineGlobalIDs returns the global identifier of each available machine.
func (m *Manager) MachineGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.machineGidToID))
	for gid, id := range m.machineGidToID {
		gids[id] = gid
	}
	return gids
}

// Machine returns the machine with the given local identifier if present.
func (m *Manager) Machine(id int) (machine *Machine, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.machines) {
		return nil, false
	}
	machine = m.machines[id]
	if machine == nil {
		return nil, false
	}
	return machine, true
}

// MachineFromGlobalID returns the machine with the given global identifier if
// present.
func (m *Manager) MachineFromGlobalID(gid uint32) (machine *Machine, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.machineGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Machine(localID)
}

// Machines returns a slice of each available machine.
func (m *Manager) Machines() []*Machine {
	m.RLock()
	defer m.RUnlock()
	mas := make([]*Machine, len(m.machines))
	for i := range m.machines {
		mas[i] = m.machines[i]
	}
	return mas
}

// ConfigurationIDs returns the identifier of each available configuration.
func (m *Manager) ConfigurationIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.configs))
	for i := range m.configs {
		ids[i] = i
	}
	return ids
}

// ConfigurationGlobalIDs returns the global identifier of each available
// configuration.
func (m *Manager) ConfigurationGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.configGidToID))
	for gid, id := range m.configGidToID {
		gids[id] = gid
	}
	return gids
}

// Configuration returns the configuration with the given identifier if
// present.
func (m *Manager) Configuration(id int) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.configs) {
		return nil, false
	}
	config = m.configs[id]
	if config == nil {
		return nil, false
	}
	return config, true
}

// ConfigurationFromGlobalID returns the configuration with the given global
// identifier if present.
func (m *Manager) ConfigurationFromGlobalID(gid uint32) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.configGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Configuration(localID)
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.RLock()
	defer m.RUnlock()
	cos := make([]*Configuration, len(m.configs))
	for i := range m.configs {
		cos[i] = m.configs[i]
	}
	return cos
}

// Size returns the number of machines and configurations in the Manager.
func (m *Manager) Size() (machines, configs int) {
	m.RLock()
	defer m.RUnlock()
	return len(m.machines), len(m.configs)
}

// AddMachine attempts to dial to the provide machine address. The machine is
// added to the Manager's pool of machines if a connection was established.
func (m *Manager) AddMachine(addr string) error {
	return m.createMachine(addr)
}

func (m *Manager) createMachine(addr string) error {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return fmt.Errorf("create machine %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	gid := h.Sum32()
	if _, machineExists := m.machineGidToID[gid]; machineExists {
		return fmt.Errorf("create machine %s error: machine already exists", addr)
	}
	id := len(m.machines)

	ma := &Machine{
		id:      id,
		gid:     gid,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}

	err = m.connect(ma)
	if err != nil {
		return fmt.Errorf("create machine %s error: %v", addr, err)
	}

	m.machines = append(m.machines, ma)
	m.machineGidToID[gid] = id

	return nil
}

func (m *Manager) connect(ma *Machine) error {
	if m.opts.noConnect {
		return nil
	}

	conn, err := grpc.Dial(ma.addr, m.opts.grpcDialOpts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}
	ma.conn = conn

	return nil
}

func (m *Manager) closeMachineConns() {
	for _, machine := range m.machines {
		err := machine.conn.Close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("machine %d: error closing connection: %v", machine.id, err)
		}
	}
}

// NewConfiguration returns a new configuration given a set of machine ids and
// a quorum size. Any given gRPC call options will be used for every RPC
// invocation on the configuration.
func (m *Manager) NewConfiguration(ids []int, quorumSize int, timeout time.Duration) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one machine")
	}
	if quorumSize > len(ids) || quorumSize < 1 {
		return nil, IllegalConfigError("invalid quourm size")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	var cmachines []*Machine
	for _, mid := range ids {
		if mid < 0 || mid >= len(m.machines) {
			return nil, MachineNotFoundError(mid)
		}
		machine := m.machines[mid]
		if machine == nil {
			return nil, MachineNotFoundError(mid)
		}
		cmachines = append(cmachines, machine)
	}

	// Machine ids are sorted by global id to
	// ensure a globally consistent configuration id.
	sort.Sort(ByGID(cmachines))

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, quorumSize)
	binary.Write(h, binary.LittleEndian, timeout)
	for _, machine := range cmachines {
		binary.Write(h, binary.LittleEndian, machine.gid)
	}
	gcid := h.Sum32()

	cid, found := m.configGidToID[gcid]
	if found {
		if m.configs[cid] == nil {
			panic(fmt.Sprintf("config with gcid %d and cid %d was nil", gcid, cid))
		}
		return m.configs[cid], nil
	}
	cid = len(m.configs)

	c := &Configuration{
		id:       cid,
		gid:      gcid,
		machines: ids,
		mgr:      m,
		quorum:   quorumSize,
		timeout:  timeout,
		defCtx:   context.Background(),
	}
	m.configs = append(m.configs, c)

	return c, nil
}

/* opts.go */

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each machine in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its machines. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for AdvRegister service

type AdvRegisterClient interface {
	AReadS(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error)
	AWriteS(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*ConfReply, error)
	AWriteN(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error)
	SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
	LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error)
	SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error)
	GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error)
	Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error)
	Fwd(ctx context.Context, in *Proposal, opts ...grpc.CallOption) (*Ack, error)
}

type advRegisterClient struct {
	cc *grpc.ClientConn
}

func NewAdvRegisterClient(cc *grpc.ClientConn) AdvRegisterClient {
	return &advRegisterClient{cc}
}

func (c *advRegisterClient) AReadS(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error) {
	out := new(ReadReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AReadS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) AWriteS(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*ConfReply, error) {
	out := new(ConfReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AWriteS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) AWriteN(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error) {
	out := new(WriteNReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/AWriteN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/SetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error) {
	out := new(LAReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/LAProp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error) {
	out := new(NewStateReply)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/SetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error) {
	out := new(Promise)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/GetPromise", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error) {
	out := new(Learn)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/Accept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advRegisterClient) Fwd(ctx context.Context, in *Proposal, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.AdvRegister/Fwd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdvRegister service

type AdvRegisterServer interface {
	AReadS(context.Context, *Conf) (*ReadReply, error)
	AWriteS(context.Context, *WriteS) (*ConfReply, error)
	AWriteN(context.Context, *WriteN) (*WriteNReply, error)
	SetCur(context.Context, *NewCur) (*NewCurReply, error)
	LAProp(context.Context, *LAProposal) (*LAReply, error)
	SetState(context.Context, *NewState) (*NewStateReply, error)
	GetPromise(context.Context, *Prepare) (*Promise, error)
	Accept(context.Context, *Propose) (*Learn, error)
	Fwd(context.Context, *Proposal) (*Ack, error)
}

func RegisterAdvRegisterServer(s *grpc.Server, srv AdvRegisterServer) {
	s.RegisterService(&_AdvRegister_serviceDesc, srv)
}

func _AdvRegister_AReadS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Conf)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AReadS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_AWriteS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteS)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AWriteS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_AWriteN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).AWriteN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_SetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).SetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_LAProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(LAProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).LAProp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewState)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).SetState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_GetPromise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Prepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).GetPromise(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Propose)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).Accept(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AdvRegister_Fwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Proposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AdvRegisterServer).Fwd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _AdvRegister_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AdvRegister",
	HandlerType: (*AdvRegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AReadS",
			Handler:    _AdvRegister_AReadS_Handler,
		},
		{
			MethodName: "AWriteS",
			Handler:    _AdvRegister_AWriteS_Handler,
		},
		{
			MethodName: "AWriteN",
			Handler:    _AdvRegister_AWriteN_Handler,
		},
		{
			MethodName: "SetCur",
			Handler:    _AdvRegister_SetCur_Handler,
		},
		{
			MethodName: "LAProp",
			Handler:    _AdvRegister_LAProp_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _AdvRegister_SetState_Handler,
		},
		{
			MethodName: "GetPromise",
			Handler:    _AdvRegister_GetPromise_Handler,
		},
		{
			MethodName: "Accept",
			Handler:    _AdvRegister_Accept_Handler,
		},
		{
			MethodName: "Fwd",
			Handler:    _AdvRegister_Fwd_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for DynaDisk service

type DynaDiskClient interface {
	GetOneN(ctx context.Context, in *GetOne, opts ...grpc.CallOption) (*GetOneReply, error)
	DWriteN(ctx context.Context, in *DRead, opts ...grpc.CallOption) (*DReadReply, error)
	DSetState(ctx context.Context, in *DNewState, opts ...grpc.CallOption) (*NewStateReply, error)
	DWriteNSet(ctx context.Context, in *DWriteNs, opts ...grpc.CallOption) (*DWriteNsReply, error)
	DSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
}

type dynaDiskClient struct {
	cc *grpc.ClientConn
}

func NewDynaDiskClient(cc *grpc.ClientConn) DynaDiskClient {
	return &dynaDiskClient{cc}
}

func (c *dynaDiskClient) GetOneN(ctx context.Context, in *GetOne, opts ...grpc.CallOption) (*GetOneReply, error) {
	out := new(GetOneReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/GetOneN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DWriteN(ctx context.Context, in *DRead, opts ...grpc.CallOption) (*DReadReply, error) {
	out := new(DReadReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DWriteN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DSetState(ctx context.Context, in *DNewState, opts ...grpc.CallOption) (*NewStateReply, error) {
	out := new(NewStateReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DSetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DWriteNSet(ctx context.Context, in *DWriteNs, opts ...grpc.CallOption) (*DWriteNsReply, error) {
	out := new(DWriteNsReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DWriteNSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dynaDiskClient) DSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.DynaDisk/DSetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DynaDisk service

type DynaDiskServer interface {
	GetOneN(context.Context, *GetOne) (*GetOneReply, error)
	DWriteN(context.Context, *DRead) (*DReadReply, error)
	DSetState(context.Context, *DNewState) (*NewStateReply, error)
	DWriteNSet(context.Context, *DWriteNs) (*DWriteNsReply, error)
	DSetCur(context.Context, *NewCur) (*NewCurReply, error)
}

func RegisterDynaDiskServer(s *grpc.Server, srv DynaDiskServer) {
	s.RegisterService(&_DynaDisk_serviceDesc, srv)
}

func _DynaDisk_GetOneN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetOne)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).GetOneN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DWriteN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DRead)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DWriteN(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DSetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DNewState)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DSetState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DWriteNSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DWriteNs)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DWriteNSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DynaDisk_DSetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DynaDiskServer).DSetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _DynaDisk_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DynaDisk",
	HandlerType: (*DynaDiskServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOneN",
			Handler:    _DynaDisk_GetOneN_Handler,
		},
		{
			MethodName: "DWriteN",
			Handler:    _DynaDisk_DWriteN_Handler,
		},
		{
			MethodName: "DSetState",
			Handler:    _DynaDisk_DSetState_Handler,
		},
		{
			MethodName: "DWriteNSet",
			Handler:    _DynaDisk_DWriteNSet_Handler,
		},
		{
			MethodName: "DSetCur",
			Handler:    _DynaDisk_DSetCur_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for SpSnRegister service

type SpSnRegisterClient interface {
	SpSnOne(ctx context.Context, in *SWriteN, opts ...grpc.CallOption) (*SWriteNReply, error)
	SCommit(ctx context.Context, in *Commit, opts ...grpc.CallOption) (*CommitReply, error)
	SSetState(ctx context.Context, in *SState, opts ...grpc.CallOption) (*SStateReply, error)
	SSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
}

type spSnRegisterClient struct {
	cc *grpc.ClientConn
}

func NewSpSnRegisterClient(cc *grpc.ClientConn) SpSnRegisterClient {
	return &spSnRegisterClient{cc}
}

func (c *spSnRegisterClient) SpSnOne(ctx context.Context, in *SWriteN, opts ...grpc.CallOption) (*SWriteNReply, error) {
	out := new(SWriteNReply)
	err := grpc.Invoke(ctx, "/proto.SpSnRegister/SpSnOne", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spSnRegisterClient) SCommit(ctx context.Context, in *Commit, opts ...grpc.CallOption) (*CommitReply, error) {
	out := new(CommitReply)
	err := grpc.Invoke(ctx, "/proto.SpSnRegister/SCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spSnRegisterClient) SSetState(ctx context.Context, in *SState, opts ...grpc.CallOption) (*SStateReply, error) {
	out := new(SStateReply)
	err := grpc.Invoke(ctx, "/proto.SpSnRegister/SSetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spSnRegisterClient) SSetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.SpSnRegister/SSetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SpSnRegister service

type SpSnRegisterServer interface {
	SpSnOne(context.Context, *SWriteN) (*SWriteNReply, error)
	SCommit(context.Context, *Commit) (*CommitReply, error)
	SSetState(context.Context, *SState) (*SStateReply, error)
	SSetCur(context.Context, *NewCur) (*NewCurReply, error)
}

func RegisterSpSnRegisterServer(s *grpc.Server, srv SpSnRegisterServer) {
	s.RegisterService(&_SpSnRegister_serviceDesc, srv)
}

func _SpSnRegister_SpSnOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SWriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SpSnRegisterServer).SpSnOne(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SpSnRegister_SCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Commit)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SpSnRegisterServer).SCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SpSnRegister_SSetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SState)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SpSnRegisterServer).SSetState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SpSnRegister_SSetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SpSnRegisterServer).SSetCur(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _SpSnRegister_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.SpSnRegister",
	HandlerType: (*SpSnRegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SpSnOne",
			Handler:    _SpSnRegister_SpSnOne_Handler,
		},
		{
			MethodName: "SCommit",
			Handler:    _SpSnRegister_SCommit_Handler,
		},
		{
			MethodName: "SSetState",
			Handler:    _SpSnRegister_SSetState_Handler,
		},
		{
			MethodName: "SSetCur",
			Handler:    _SpSnRegister_SSetCur_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *State) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *State) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	if m.Timestamp != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Timestamp))
	}
	if m.Writer != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Writer))
	}
	return i, nil
}

func (m *Conf) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Conf) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.This != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.This))
	}
	if m.Cur != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur))
	}
	return i, nil
}

func (m *ConfReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n1, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Abort {
		data[i] = 0x10
		i++
		if m.Abort {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x1a
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Id))
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Version))
	}
	return i, nil
}

func (m *Blueprint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Blueprint) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			data[i] = 0xa
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FaultTolerance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.FaultTolerance))
	}
	if m.Epoch != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Epoch))
	}
	return i, nil
}

func (m *NewCur) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewCur) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n2, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CurC != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	return i, nil
}

func (m *NewCurReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewCurReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.New {
		data[i] = 0x8
		i++
		if m.New {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Read) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Read) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n3, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ReadReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n4, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n5, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *WriteS) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteS) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n6, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Conf != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n7, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *WriteN) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteN) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Next != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Next.Size()))
		n8, err := m.Next.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *WriteNReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteNReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n9, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.State != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n10, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.LAState != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.LAState.Size()))
		n11, err := m.LAState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *LAProposal) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LAProposal) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n12, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Prop != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Prop.Size()))
		n13, err := m.Prop.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *LAReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LAReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n14, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.LAState != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.LAState.Size()))
		n15, err := m.LAState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *NewState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n16, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.State != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n17, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.LAState != nil {
		data[i] = 0x22
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.LAState.Size()))
		n18, err := m.LAState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *NewStateReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewStateReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n19, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CV) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CV) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Val.Size()))
		n20, err := m.Val.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *Prepare) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Prepare) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Rnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	return i, nil
}

func (m *Promise) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Promise) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n21, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Rnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Val.Size()))
		n22, err := m.Val.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Dec != nil {
		data[i] = 0x22
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Dec.Size()))
		n23, err := m.Dec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *Propose) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Propose) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurC))
	}
	if m.Val != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Val.Size()))
		n24, err := m.Val.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *Learn) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Learn) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n25, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Dec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Dec.Size()))
		n26, err := m.Dec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Learned {
		data[i] = 0x18
		i++
		if m.Learned {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Proposal) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proposal) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prop != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Prop.Size()))
		n27, err := m.Prop.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *Ack) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Ack) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetOne) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetOne) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n28, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Next != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Next.Size()))
		n29, err := m.Next.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *GetOneReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetOneReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Next != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Next.Size()))
		n30, err := m.Next.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n31, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *DRead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DRead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n32, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Prop != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Prop.Size()))
		n33, err := m.Prop.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *DReadReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DReadReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n34, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n35, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x1a
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DNewState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DNewState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n36, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n37, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.State != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n38, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *DWriteNs) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DWriteNs) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Conf.Size()))
		n39, err := m.Conf.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DWriteNsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DWriteNsReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n40, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SWriteN) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SWriteN) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurL != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurL))
	}
	if m.This != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.This))
	}
	if m.Rnd != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	if m.Prop != nil {
		data[i] = 0x22
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Prop.Size()))
		n41, err := m.Prop.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *SWriteNReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SWriteNReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n42, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			data[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.State != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n43, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *Commit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Commit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurL != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurL))
	}
	if m.This != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.This))
	}
	if m.Rnd != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Rnd))
	}
	if m.Commit {
		data[i] = 0x20
		i++
		if m.Commit {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Collect != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Collect.Size()))
		n44, err := m.Collect.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *CommitReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n45, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Committed != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Committed.Size()))
		n46, err := m.Committed.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Collected != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Collected.Size()))
		n47, err := m.Collected.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *SState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurL != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.CurL))
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n48, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.State != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.State.Size()))
		n49, err := m.State.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}

func (m *SStateReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SStateReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasNext {
		data[i] = 0x8
		i++
		if m.HasNext {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Cur != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(data, i, uint64(m.Cur.Size()))
		n50, err := m.Cur.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func encodeFixed64DcSmartMerge(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32DcSmartMerge(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDcSmartMerge(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *State) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Timestamp))
	}
	if m.Writer != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Writer))
	}
	return n
}

func (m *Conf) Size() (n int) {
	var l int
	_ = l
	if m.This != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.This))
	}
	if m.Cur != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Cur))
	}
	return n
}

func (m *ConfReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Abort {
		n += 2
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Id))
	}
	if m.Version != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Version))
	}
	return n
}

func (m *Blueprint) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	if m.FaultTolerance != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.FaultTolerance))
	}
	if m.Epoch != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Epoch))
	}
	return n
}

func (m *NewCur) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	return n
}

func (m *NewCurReply) Size() (n int) {
	var l int
	_ = l
	if m.New {
		n += 2
	}
	return n
}

func (m *Read) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *ReadReply) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteS) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteN) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteNReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *LAProposal) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *LAReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *NewState) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *NewStateReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *CV) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Prepare) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	return n
}

func (m *Promise) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Dec != nil {
		l = m.Dec.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Propose) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Learn) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Dec != nil {
		l = m.Dec.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Learned {
		n += 2
	}
	return n
}

func (m *Proposal) Size() (n int) {
	var l int
	_ = l
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Ack) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetOne) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *GetOneReply) Size() (n int) {
	var l int
	_ = l
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *DRead) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *DReadReply) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *DNewState) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *DWriteNs) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *DWriteNsReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *SWriteN) Size() (n int) {
	var l int
	_ = l
	if m.CurL != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurL))
	}
	if m.This != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.This))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *SWriteNReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	if m.CurL != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurL))
	}
	if m.This != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.This))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Commit {
		n += 2
	}
	if m.Collect != nil {
		l = m.Collect.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *CommitReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Committed != nil {
		l = m.Committed.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Collected != nil {
		l = m.Collected.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *SState) Size() (n int) {
	var l int
	_ = l
	if m.CurL != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurL))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *SStateReply) Size() (n int) {
	var l int
	_ = l
	if m.HasNext {
		n += 2
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func sovDcSmartMerge(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDcSmartMerge(x uint64) (n int) {
	return sovDcSmartMerge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *State) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writer", wireType)
			}
			m.Writer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Writer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Conf) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Conf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Conf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field This", wireType)
			}
			m.This = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.This |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			m.Cur = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cur |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Abort = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Blueprint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blueprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blueprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultTolerance", wireType)
			}
			m.FaultTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FaultTolerance |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewCur) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewCur: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewCur: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewCurReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewCurReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewCurReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.New = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Read) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Read: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Read: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteS) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteN) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Blueprint{}
			}
			if err := m.Next.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteNReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteNReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteNReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &Blueprint{}
			}
			if err := m.LAState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LAProposal) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LAProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LAProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &Blueprint{}
			}
			if err := m.Prop.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LAReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LAReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LAReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &Blueprint{}
			}
			if err := m.LAState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &Blueprint{}
			}
			if err := m.LAState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewStateReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CV) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Blueprint{}
			}
			if err := m.Val.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Promise) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Promise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Promise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &CV{}
			}
			if err := m.Val.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dec == nil {
				m.Dec = &Blueprint{}
			}
			if err := m.Dec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Propose) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Propose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Propose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &CV{}
			}
			if err := m.Val.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Learn) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Learn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Learn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dec == nil {
				m.Dec = &Blueprint{}
			}
			if err := m.Dec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &Blueprint{}
			}
			if err := m.Prop.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOne) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOne: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOne: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Blueprint{}
			}
			if err := m.Next.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOneReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOneReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOneReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Blueprint{}
			}
			if err := m.Next.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DRead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &Blueprint{}
			}
			if err := m.Prop.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DReadReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DReadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DReadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNewState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNewState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNewState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DWriteNs) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWriteNs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWriteNs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DWriteNsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWriteNsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWriteNsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SWriteN) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SWriteN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SWriteN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurL", wireType)
			}
			m.CurL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurL |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field This", wireType)
			}
			m.This = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.This |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &Blueprint{}
			}
			if err := m.Prop.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SWriteNReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SWriteNReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SWriteNReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurL", wireType)
			}
			m.CurL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurL |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field This", wireType)
			}
			m.This = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.This |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Commit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collect == nil {
				m.Collect = &Blueprint{}
			}
			if err := m.Collect.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committed == nil {
				m.Committed = &Blueprint{}
			}
			if err := m.Committed.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collected == nil {
				m.Collected = &Blueprint{}
			}
			if err := m.Collected.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurL", wireType)
			}
			m.CurL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurL |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SStateReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasNext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasNext = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &Blueprint{}
			}
			if err := m.Cur.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDcSmartMerge(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDcSmartMerge
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDcSmartMerge
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDcSmartMerge(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDcSmartMerge = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDcSmartMerge   = fmt.Errorf("proto: integer overflow")
)
